# 稀疏数组（Sparse Array）

原数组

```
0 0 0 0 0 0 0 0 0 0 0 
0 0 1 0 0 0 0 0 0 0 0 
0 0 0 2 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 0  
```

稀疏数组表示

```
	row	col	val
0	11	11	2
1	1	2	1
2	2	3	2
```

## 转换思路

### 二维数组转稀疏数组

1 遍历原始的二维数组，得到有效数据的个数sum

2 根据sum就可以创建稀疏数组sparseArr int[sum+1]\[3]

3 将二维数据的有效数据存入到稀疏数组

### 稀疏数组转二维数组

1 先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组

2 在读取稀疏数组的后几行数据，并赋给原始的二维数组即可

## 代码实现

```java
public class hello {
    public static  void  main(String[] args){
        int Arr[][] = new int[11][11];
        Arr[1][2] = 1;
        Arr[2][3] = 2;

        System.out.println("原始的二维数组");

        for(int[] row : Arr){       //遍历初始数组
            for(int data : row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }

        int sum = 0;
        for(int i = 0;i < Arr.length;i++){
            for(int j = 0;j < Arr.length;j++){
                if(Arr[i][j] != 0){
                    sum++;      //记录原始数组中有效数据的个数
                }
            }
        }

        int sparseArr[][] = new int[sum + 1][3];    //建立稀疏数组
        sparseArr[0][0] = Arr.length;
        sparseArr[0][1] = Arr[0].length;
        sparseArr[0][2] = sum;

        int count = 0;      //计数器

        for(int i = 0;i < Arr.length;i++){
            for(int j = 0;j < Arr.length;j++){
                if(Arr[i][j] != 0){                 //为稀疏数组赋值
                    count++;
                    sparseArr[count][0] = i;
                    sparseArr[count][1] = j;
                    sparseArr[count][2] = Arr[i][j];
                }
            }
        }

        System.out.println("========================================");
        System.out.println("转化后得到的稀疏数组为");
        for (int i = 0; i < sparseArr.length; i++) {
            System.out.printf("%d\t%d\t%d\t\n",sparseArr[i][0],sparseArr[i][1],sparseArr[i][2]);
        }
        System.out.println("========================================");
        System.out.println("恢复后的原始数组");
        int Arr2[][] = new int[sparseArr[0][0]][sparseArr[0][1]];       //创建新的数组

        for(int i = 1;i < sparseArr.length;i++){                    //恢复原始数组
            Arr2[sparseArr[i][0]][sparseArr[i][1]] = sparseArr[i][2];
        }

        for(int[] row : Arr2){              //输出恢复后的数组
            for(int data : row){
                System.out.printf("%d\t",data);
            }
            System.out.println();
        }
    }
}
```

# 队列(Queue)

队列是一个有序列表，可以用数组或者链表来实现

遵循先入先出原则，即：先存入队列的数据，要先取出。后存入的数据要后取出

## 数组模拟队列

因为队列的输入，输出是分别从前后端来处理，因此需要两个变量front，rear分别记录队列

前后端的下标，front会随着数据输出而改变，而rear则是随着数据的输入而改变。

### 思路

当我们要将数据存入到队列中时

1.将尾指针往后移：rear+1，当front == rear （即队列为空）或rear <maxSize - 1.

2.若尾指针rear小于队列最大下标maxSize - 1，则将数据存入rear所指的数组元素中，否则无

法存入数据。rear == maxSize - 1（队列已满）

## 普通队列

### 代码实现

```java
import java.util.Scanner;

public class hello {
    public static  void  main(String[] args){
        ArrayQueue arrayQueue = new ArrayQueue(3);
        char key;
        Scanner scanner =  new Scanner(System.in);
        boolean loop = true;
        while(loop){		//目录
            System.out.println("========================================");
            System.out.printf("s(show):显示队列\n");
            System.out.printf("e(exit):退出程序\n");
            System.out.printf("a(add):添加数据到队列\n");
            System.out.printf("g(get):从队列取出数据\n");
            System.out.printf("h(head):查看对列头的数据\n");
            System.out.println("========================================");
            key = scanner.next().charAt(0);
            switch (key){
                case 's':			//展示队列
                    arrayQueue.showQueue();
                    break;
                case 'a':			//添加数据到队列
                    System.out.printf("输出一个数\n");
                    int value = scanner.nextInt();
                    arrayQueue.addQueue(value);
                    break;
                case 'g':			//从队列中取出数据
                    try {
                        int res = arrayQueue.getQueue();
                        System.out.printf("取出的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':				//展示队列中的首个数据
                    try {
                        int res = arrayQueue.headQueue();
                        System.out.printf("队列头的的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':			//结束程序
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;


            }
        }
        System.out.println("程序以退出");
    }
}


class ArrayQueue{
    private int maxSize;		//数组的长度
    private int front;			//头指针
    private int rear;			//尾指针
    private int[] arr;			//模拟队列

    public ArrayQueue(int arrMaxSize){		//使用构造器创建数组
        maxSize = arrMaxSize;
        arr = new int[maxSize];
        front = -1;
        rear = -1;
    }

    public boolean isFull(){		//判断队列是否已满
        return rear >= maxSize - 1;
    }

    public boolean isEmpty(){		//判断队列是否为空
        return rear == front;
    }

    public void addQueue(int n){		//添加数据到队列，需先判断队列是否已满
        if(isFull()){
            System.out.println("Queue is full");
            return;
        }
        rear++;
        arr[rear] = n;
    }

    public int getQueue(){				//从队列中取出数据，需先判断队列是否为空
        if(isEmpty()){
            throw new RuntimeException("Queue is empty");       //throw本身就会return函数
         //   return;
        }
        front++;
        return arr[front];
    }

    public void showQueue(){			//展示队列
        if(isEmpty()){
            System.out.println("Queue is enpty");
            return;
        }
        for (int i = front; i < arr.length; i++) {
            System.out.printf("arr[%d]=%d\n",i,arr[i]);
        }
    }

    public int headQueue(){			//查看队列的首个数据
        if(isEmpty()){
            throw new RuntimeException("Queue is empty");
        }
        return arr[front+1];
    }
}
```

### 问题分析，并优化方法

1.该队列只能使用以此，不能复用

2.将这个数组使用算法，改进程一个环形的队列

### 实现思路

1.front变量的含义做一个调整：front就指向队列的第一个元素，也就是说arr[front]就是队列的第一个元素

front初始值 = 0

2.rear变量的含义做一个调整：rear指向队列最后一个元素的后一个位置，因为希望空出一个空间作为约定

rear初始值 = 0

3.当队列满时，条件时(rear + 1) % maxSize == front[已满]

4.当队列为空时，rear == front[空]

5.队列中有效的数据个数(rear + maxSize - front) % maxSize

### 代码实现

```java
import java.util.Scanner;

public class hello {
    public static  void  main(String[] args){

        CircleArray circleArray = new CircleArray(4);		
        //4的长度只能存储3个元素，防止数组越界
        char key;
        Scanner scanner =  new Scanner(System.in);
        boolean loop = true;
        while(loop){      //目录
            System.out.println("========================================");
            System.out.printf("s(show):显示队列\n");
            System.out.printf("e(exit):退出程序\n");
            System.out.printf("a(add):添加数据到队列\n");
            System.out.printf("g(get):从队列取出数据\n");
            System.out.printf("h(head):查看对列头的数据\n");
            System.out.println("========================================");
            key = scanner.next().charAt(0);
            switch (key){
                case 's':        //展示队列
                    circleArray.showQueue();
                    break;
                case 'a':        //添加数据到队列
                    System.out.printf("输出一个数\n");
                    int value = scanner.nextInt();
                    circleArray.addQueue(value);
                    break;
                case 'g':        //从队列中取出数据
                    try {
                        int res = circleArray.getQueue();
                        System.out.printf("取出的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'h':           //展示队列中的首个数据
                    try {
                        int res = circleArray.headQueue();
                        System.out.printf("队列头的的数据是%d\n",res);
                    }catch (Exception e){
                        System.out.println(e.getMessage());
                    }
                    break;
                case 'e':        //结束程序
                    scanner.close();
                    loop = false;
                    break;
                default:
                    break;


            }
        }
        System.out.println("程序以退出");

    }
}


class CircleArray{
    private int maxSize;      //数组的长度
    private int front;       //头指针
    private int rear;        //尾指针
    private int[] arr;

    public  CircleArray(int arrMaxSize){
        maxSize = arrMaxSize;
        arr = new int[maxSize];
    }

    public boolean isFull(){			//尾指针下一个位置为头指针时表示队列已满
        return (rear + 1) % maxSize == front;
    }

    public boolean isEmpty(){     //判断队列是否为空
        return rear == front;
    }

    public void addQueue(int n){      //添加数据到队列
        if(isFull()){
            System.out.println("Queue is full");
            return;
        }
        arr[rear] = n;			
        rear = (rear + 1) % maxSize;		//环形队列，对最大长度取余防止数组越界
    }

    public int getQueue(){          //从队列中取出数据
        if(isEmpty()){
            throw new RuntimeException("Queue is empty");
        }
        int value = arr[front];
        front = (front + 1) % maxSize;
        return value;
    }

    public void showQueue(){         //展示队列
        if(isEmpty()){
            System.out.println("Queue is enpty");
            return;
        }
        for (int i = front;i < front + size();i++) {		//从头指针开始，循环次数为元素个数
            System.out.printf("arr[%d]=%d\n",i % maxSize,arr[i % maxSize]);
            //i % maxSize环形数组
        }
    }

    public int size(){				//计算数组元素个数
        return (rear + maxSize - front) % maxSize;
    }

    public int headQueue(){          //查看队列的首个数据
        if(isEmpty()){
            throw new RuntimeException("Queue is empty");
        }
        return arr[front];
    }
}
```

# 链表（Linked List）

链表时以节点的方式来存储，是链式存储，所以链表的各个节点不一定是连续存储

每个节点都含有data域和next域

链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定

## 单链表

``` java
public class hello {
    public static  void  main(String[] args){
        HeroNode hero1 = new HeroNode(1,"宋江","及时雨");		//创建节点
        HeroNode hero2 = new HeroNode(2,"卢俊义","玉麒麟");
        HeroNode hero3 = new HeroNode(3,"吴用","智多星");
        HeroNode hero4 = new HeroNode(4,"林冲","豹子头");

        SingleLinkedList singleLinkedList = new SingleLinkedList();	//创建链表

//        singleLinkedList.add(hero1);		//使用尾接法
//        singleLinkedList.add(hero2);
//        singleLinkedList.add(hero3);
//        singleLinkedList.add(hero4);

        singleLinkedList.addByOrder(hero1);		//使用选查法
        singleLinkedList.addByOrder(hero4);
        singleLinkedList.addByOrder(hero2);
        singleLinkedList.addByOrder(hero3);

        singleLinkedList.list();	//展示链表

        HeroNode newhero2 = new HeroNode(2,"小炉","玉麒麟~~");
        singleLinkedList.upDate(newhero2);		//更改节点信息

        System.out.println("=================");
        singleLinkedList.list();

        singleLinkedList.del(1);	//删除节点
        singleLinkedList.del(4);
        singleLinkedList.del(2);
        singleLinkedList.del(3);

        System.out.println("=================");
        singleLinkedList.list();
    }
}

class SingleLinkedList{
    private HeroNode head = new HeroNode(0,"","");	//创建头节点

    public void list(){
        if(head.next == null){
            System.out.println("list is empty");
            return;
        }
        HeroNode temp = head.next;
        while (true){
            if(temp == null){
                break;
            }
            System.out.println(temp);		//调用toString方法输出temp信息
            temp = temp.next;
        }
    }

    public void  add(HeroNode heroNode){
        HeroNode temp = head;
        while (true){
            if(temp.next == null){
                break;
            }
            temp = temp.next;
        }
        temp.next = heroNode;
    }

    public void addByOrder(HeroNode heroNode){
        HeroNode temp = head;
        boolean flag = false;
        while (true){
            if(temp.next == null){
                break;
            }
            if(temp.next.no > heroNode.no){
                break;
            }else if(temp.next.no == heroNode.no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if(flag){
            System.out.printf("准备插入的英雄编号%d，已经存在,无法插入\n",heroNode.no);
        } else {
            heroNode.next = temp.next;
            temp.next = heroNode;
        }
    }

    public void upDate(HeroNode heroNode){
        if(head.next == null){
            System.out.println("list is empty");
            return;
        }
        HeroNode temp = head.next;
        boolean flag = false;
        while (true){
            if(temp ==null){
                break;
            }
            if(temp.no == heroNode.no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if(flag){
            temp.name = heroNode.name;
            temp.nickname = heroNode.nickname;
        } else {
            System.out.printf("没有找到编号%d的节点",heroNode.no);
        }
    }

    public void del(int no){
        HeroNode temp = head;
        boolean flag = false;
        while (true){
            if(temp.next == null){
                break;
            }
            if(temp.next.no == no){
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if(flag){
            temp.next = temp.next.next;
        } else {
            System.out.printf("要删除的%d节点不存在\n",no);
        }
    }
}


class HeroNode{
    public  int no;
    public  String name;
    public  String nickname;
    public HeroNode next;

    public HeroNode(int no,String name, String nickname){
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    public String toString() {		//重写toString
       return "HeroNode [no=" + no + ",name=" + name +",nickname=" + nickname + "]";
    }
}
```



## 双向链表

```java
public class hello {
    public static  void  main(String[] args){
        System.out.println("双向链表测试");

        HeroNode hero1 = new HeroNode(1,"宋江","及时雨");      //创建节点
        HeroNode hero2 = new HeroNode(2,"卢俊义","玉麒麟");
        HeroNode hero3 = new HeroNode(3,"吴用","智多星");
        HeroNode hero4 = new HeroNode(4,"林冲","豹子头");

        DoubleLinkedList doubleLinkedList = new DoubleLinkedList();
        doubleLinkedList.add(hero1);
        doubleLinkedList.add(hero2);
        doubleLinkedList.add(hero3);
        doubleLinkedList.add(hero4);

        doubleLinkedList.list();

        HeroNode newHeroNode = new HeroNode(2,"公孙胜","入云龙");
        doubleLinkedList.upDate(newHeroNode);
        doubleLinkedList.list();
        
        doubleLinkedList.del(3);
        doubleLinkedList.list();
    }
}



class DoubleLinkedList {

    private HeroNode head = new HeroNode(0, "", "");    //创建头节点

    public HeroNode getHead() {
        return head;
    }

    public void list() {
        if (head.next == null) {
            System.out.println("list is empty");
            return;
        }
        HeroNode temp = head.next;
        while (true) {
            if (temp == null) {
                break;
            }
            System.out.println(temp);        //调用toString方法输出temp信息
            temp = temp.next;
        }
    }

    public void add(HeroNode heroNode) {
        HeroNode temp = head;

        while (true) {
            if (temp.next == null) {
                break;
            }
            temp = temp.next;
        }

        temp.next = heroNode;
        heroNode.pre = temp;
    }

    public void upDate(HeroNode heroNode) {
        if (head.next == null) {
            System.out.println("list is empty");
            return;
        }
        HeroNode temp = head.next;
        boolean flag = false;
        while (true) {
            if (temp == null) {
                break;
            }
            if (temp.no == heroNode.no) {
                flag = true;
                break;
            }
            temp = temp.next;
        }
        if (flag) {
            temp.name = heroNode.name;
            temp.nickname = heroNode.nickname;
        } else {
            System.out.printf("没有找到编号%d的节点", heroNode.no);
        }
    }

    public void del(int no) {
        if (head.next == null) {
            System.out.println("List is empty");
        }

        HeroNode temp = head.next;
        boolean flag = false;

        while (true) {
            if (temp == null) {
                break;
            }
            if (temp.no == no) {
                flag = true;
                break;
            }
            temp = temp.next;
        }

        if (flag) {
            temp.pre.next = temp.next;
            if (temp.next != null) {
                temp.next.pre = temp.pre;
            }
        } else {
            System.out.printf("要删除的%d节点不存在\n", no);
        }
    }
}


class HeroNode{
    public  int no;
    public  String name;
    public  String nickname;
    public HeroNode next;
    public  HeroNode pre;

    public HeroNode(int no,String name, String nickname){
        this.no = no;
        this.name = name;
        this.nickname = nickname;
    }

    public String toString() {    //重写toString
        return "HeroNode [no=" + no + ",name=" + name +",nickname=" + nickname + "]";
    }
}
```



## 环形链表



```java
public class hello {
    public static  void  main(String[] args){
        CircleSingleLinkedList circleSingleLinkedList = new CircleSingleLinkedList();
        circleSingleLinkedList.addBoy(125);
        circleSingleLinkedList.showBoy();

        circleSingleLinkedList.countBoy(10,20,125);
    }
}



class CircleSingleLinkedList{

    private Boy first = new Boy(-1);	

    public void addBoy(int nums){
        if(nums < 1){
            System.out.println("数据错误");
            return;
        }

        Boy curBoy = null;		//辅助指针

        for(int i = 1;i <= nums;i++){
            Boy boy = new Boy(i);		//新建节点
            if(i == 1){
                first = boy;		
                first.setNext(first);
                curBoy = first;		//第一个节点的next指向自身
            } else {
                curBoy.setNext(boy);
                boy.setNext(first);		//构成环形
                curBoy = boy;
            }

        }
    }

    public void showBoy() {
        if (first == null) {
            System.out.println("List is empty");
            return;
        }

        Boy curBoy = first;		//辅助指针遍历链表
        while (true) {
            System.out.printf("小孩的编号%d \n", curBoy.getNo());
            if (curBoy.getNext() == first) {	//当辅助指针指向头节点时遍历完成
                break;
            }
            curBoy = curBoy.getNext();

        }
    }

    public void countBoy(int startNo,int countNum,int nums){	//startNo表示起始节点
        if(first == null || startNo < 1 || startNo > nums){
            System.out.println("参数输入有误");
            return;
        }
        Boy helper = first;		
        while(true){
            if(helper.getNext() == first){	//helper标记first的前驱节点
                break;
            }
            helper = helper.getNext();
        }
        
        for(int j = 0;j < startNo - 1;j++){		//移动startNo位
            first = first.getNext();
            helper = helper.getNext();
        }
        
        while (true){
            if(helper == first){
                break;
            }

            for(int j = 0;j < countNum - 1;j++){		//遍历countNum次选出出圈节点
                first = first.getNext();
                helper = helper.getNext();
            }
            System.out.printf("小孩%d出圈\n",first.getNo());
            first = first.getNext();	//first后移
            helper.setNext(first);	//helper指向first
        }
        System.out.printf("最后留在圈中的小孩编号为%d\n",helper.getNo());
    }
}




class Boy{
    private int no;
    private Boy next;

    public Boy(int no){
        this.no = no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public void setNext(Boy next) {
        this.next = next;
    }

    public Boy getNext() {
        return next;
    }

    public int getNo() {
        return no;
    }

}
```



# 栈（Stack）

栈是一个先入后出的有序列表

栈是限制线性表中的元素插入和删除只能在线性表一端进行的一种特殊线性表

允许插入和删除的一端，为变化的一端，成为栈顶（Top），另一端为固定的

一端，成为栈底（Bottom）

## 应用场景

子程序的调用

处理递归调用

表达式的转换与求值

二叉树的遍历

DFS

## 实现思路

使用数组来模拟栈

定义一个top来表示栈顶，初始化为-1

入栈的操作，当有数据加入到栈顶是，top++;stact[top] = data;

出栈的操作, int value = stack[top];top--,return value;



## 代码实现



```java
import java.util.Scanner;

public class hello {
    public static  void  main(String[] args){
        ArrayStack stack = new ArrayStack(4);
        String key = "";
        boolean loop = true;
        Scanner scanner = new Scanner(System.in);

        while(loop){
            System.out.println("show:显示栈");
            System.out.println("exit:退出程序");
            System.out.println("push:添加数据道栈");
            System.out.println("pop:从栈取出数据");
            System.out.println("请输入你的选择");
            key = scanner.next();
            switch (key){
                case  "show":
                    stack.list();
                    break;
                case  "push":
                    System.out.println("请输入一个数");
                    int value = scanner.nextInt();
                    stack.push(value);
                    break;
                case  "pop":
                    try {			//try catch方法处理异常
                        int res = stack.pop();
                        System.out.printf("出栈的数据是%d\n",res);
                    } catch (Exception e){
                        e.printStackTrace();
                    }
                    break;
                case "exit":
                    scanner.close();		//关闭输入流
                    loop = false;
                    break;
                default:
                    break;
            }
        }
        System.out.println("程序结束");
    }
}

class ArrayStack{
    private int maxSize;
    private int[] stack;
    private int top = -1;

    public ArrayStack(int maxSize){			//构造器创建栈
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    public boolean isFull(){
        return top == maxSize-1;
    }

    public boolean isEmpty(){
        return top == -1;
    }

    public void push(int value){			//入栈
        if(isFull()){
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }

    public int pop(){			//出栈
        if(isEmpty()){
            throw new RuntimeException("栈空");
        }
        int value = stack[top];
        top--;
        return value;
    }

    public void list(){			//显示栈
        if(isEmpty()){
            System.out.println("栈空");
        }
        for(int i = top ;i >= 0;i--){
            System.out.printf("stack[%d] = %d\n",i,stack[i]);
        }
    }

}
```



## 栈实现综合计算器

### 实现思路

创建两个栈：数栈、符号栈；数栈存放表达式中的数字，符号栈存放运算符
设置一个扫描字符串索引index，一个字符一个字符的扫描表达式expression
当扫描为运算符时：
当符号栈为空，直接压入运算符
当符号栈不为空，判断栈中运算符与当前运算符优先级。当前运算符优先级小于或等于栈中运算符，拿出数栈的两个数字和栈中的栈顶运算符运算，然后将结果压入数栈，将当前运算符压入符号栈
当运算符扫描完，判断符号栈是否空，不为空（肯定只剩一个符号），弹出数栈两个数据符号栈运算符，计算得到结果压入数栈，该结果就是表达式运算结果


### 代码实现

```java
import java.util.Scanner;

public class hello {
    public static void main(String[] args) {
        String expression = "701+20*6-4";

        ArrayStack numStack = new ArrayStack(50);		//建立两个栈分别存储数字与运算符
        ArrayStack operStack = new ArrayStack(50);

        int index = 0;
        int num1 = 0;
        int num2 = 0;
        int oper = 0;
        int res = 0;
        char ch = ' ';
        String keepNum = "";

        while (true) {
//            System.out.println("====================================");
//            numStack.list();
//            System.out.println("------------------------------------");
//            operStack.list();
//            System.out.println("====================================");
            ch = expression.substring(index, index + 1).charAt(0);
            //取出expression中的字符
            if (operStack.isOper(ch)) {				//判断改字符是数字还是运算符
                //当下一个字符住运算符时
                if (!operStack.isEmpty()) {			//当运算符栈不空时
                    if (operStack.priority(ch) <= operStack.priority(operStack.peek())) {
                        //要插入的运算符优先级高于栈顶的运算符优先级或相同
                        num1 = numStack.pop();		//分别取出两个数字
                        num2 = numStack.pop();
                        oper = operStack.pop();		//取出一个运算符
                        res = numStack.cal(num1, num2, oper);
                        //            System.out.println("1计算结果为" + res);
                        numStack.push(res);		//计算结果后压入数栈
                        operStack.push(ch);		//将运算符压入栈
                    } else {
                        //要插入的运算符优先级低于栈顶的运算符优先级，则直接压入
                        operStack.push(ch);
                    }
                } else {
                    //当运算符栈空时
                    operStack.push(ch);
                }
            } else {
                //当下一个字符时数字时
                keepNum += ch;		//将下一个字符加入字符串
				//如果该数为最后一个字符则直接压入
                if(index == expression.length() - 1 ){
                    numStack.push(Integer.parseInt(keepNum));	//使用强转使字符串变为整形
                    keepNum = "";
                }else {
                    if (operStack.isOper(expression.substring(index + 1, index + 2).charAt(0))) {
                        //如果下一个字符是运算符则压入，否则跳过
                        numStack.push(Integer.parseInt(keepNum));
                        keepNum = "";
                    }
                }
            }
            index++;	
            if (index >= expression.length()) {		//遍历完成
                break;
            }
        }

        while (true) {
            if (operStack.isEmpty()) {
                break;
            }
            num1 = numStack.pop();
            num2 = numStack.pop();
            oper = operStack.pop();
            res = numStack.cal(num1, num2, oper);
            //         System.out.println("计算结果为" + res);
            numStack.push(res);
        }
        System.out.printf("表达式%s = %d", expression, numStack.pop());
    }
}

class ArrayStack {
    private int maxSize;
    private int[] stack;
    private int top = -1;

    public ArrayStack(int maxSize) {
        this.maxSize = maxSize;
        stack = new int[maxSize];
    }

    public int peek() {		//获得栈顶的信息
        if (isEmpty()) {	//栈为空时返回-1
            return -1;
        }
        return stack[top];
    }

    public boolean isFull() {
        return top == maxSize - 1;
    }

    public boolean isEmpty() {
        return top == -1;
    }

    public void push(int value) {
        if (isFull()) {
            System.out.println("栈满");
            return;
        }
        top++;
        stack[top] = value;
    }

    public int pop() {
        if (isEmpty()) {
            throw new RuntimeException("栈空");
        }
        int value = stack[top];
        top--;
        return value;
    }

    public void list() {
        if (isEmpty()) {
            System.out.println("栈空");
        }
        for (int i = top; i >= 0; i--) {
            System.out.printf("stack[%d] = %d\n", i, stack[i]);
        }
    }

    public int priority(int oper) {		//判断运算符的优先级
        if (oper == '*' || oper == '/') {
            return 1;
        } else if (oper == '+' || oper == '-') {
            return 0;
        } else {
            return -1;
        }
    }

    public boolean isOper(char val) {		//判断运算符的种类然后计算得数
        return val == '*' || val == '/' || val == '+' || val == '-';
    }

    public int cal(int a, int b, int oper) {
        int res = 0;
        switch (oper) {
            case '+':
                res = a + b;
                break;
            case '-':
                res = b - a;
                break;
            case '*':
                res = a * b;
                break;
            case '/':
                res = b / a;
                break;
        }
        return res;
    }

}



```



## 逆波兰计算器



```
import java.util.ArrayList;
import java.util.List;

public class hello {
    public static void main(String[] args) {
        String suffixExpression = "3 4 + 5 * 6 -";


        List<String> rpnList = getListString(suffixExpression);
        System.out.println("rpnList = " +  rpnList);
    }

    public static List<String> getListString(String suffixExpression){
        String[] split = suffixExpression.split(" ");
        List<String> list = new ArrayList<String>();
        for(String ele: split){
            list.add(ele);
        }
        return list;
    }
}
```



```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Stack;

public class hello {
    public static void main(String[] args) {
        String suffixExpression = "4 5 * 8 - 60 + 8 2 / +";
        //建立字符串集合对字符串进行分割
        List<String> rpnList = getListString(suffixExpression);		
        //输出分割后的结果
        System.out.println("rpnList = " + rpnList);
        int res = calculate(rpnList);
        System.out.println("计算的结果是 = " + res);
    }

    public static List<String> getListString(String suffixExpression) {
        //将字符串以空格进行分割
        String[] split = suffixExpression.split(" ");
        //建立新的字符串集合
        List<String> list = new ArrayList();
        //建立字符串数组来存储分割后的字符串
        String[] var3 = split;
        int var4 = split.length;
		//遍历数组将数组元素存入到新的链表中
        for(int var5 = 0; var5 < var4; var5++) {
            String ele = var3[var5];
            list.add(ele);
        }
        return list;
    }

    public static int calculate(List<String> ls) {
        Stack<String> stack = new Stack();	//新建栈
        Iterator var2 = ls.iterator();		//使用迭代器遍历栈

        while(var2.hasNext()) {			//var2.hasNext()当还有元素可遍历时返回true
            //item储存遍历出的数据
            String item = (String)var2.next();
            if (item.matches("\\d+")) {	//当取出的元素为数字时
                stack.push(item);	//数字入栈
            } else {		//当取出的元素为运算符时
                //弹出两个数字元素并转为整形	
                int num2 = Integer.parseInt((String)stack.pop());	
                int num1 = Integer.parseInt((String)stack.pop());
                int res = 0;
                if (item.equals("+")) {
                    res = num1 + num2;
                } else if (item.equals("-")) {
                    res = num1 - num2;
                } else if (item.equals("*")) {
                    res = num1 * num2;
                } else {
                    if (!item.equals("/")) {
                        throw new RuntimeException("运算符有误");
                    }
                    res = num1 / num2;
                }
                //将数字转为字符串入栈
                stack.push(res+"");
            }
        }
		//当遍历完表达式后返回最后的结果
        return Integer.parseInt((String)stack.pop());
    }
}
```



### 中缀表达式转后缀表达式

#### 实现思路

1.初始化两个栈s1,s2

2.从左至右扫描中缀表达式

3.遇到操作数时直接压入s2

4.当遇到运算符时，比较其与s1栈顶的运算符优先级:

​	（1）.如果s1为空，或栈顶运算符为左括号"("，则直接将此运算符入栈

​	（2）.否则，若优先级比栈顶运算符的高，也将运算符压入s1

​	（3）.否则将s1栈顶的运算符弹出并压入到s2中，再次转到（4）与s1中心得栈顶运算符相比较

5.遇到括号时:

​	（1）如果时左括号"("，则直接压入s1

​	（2）如果时右括号")"，则以此弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃

6.重复步骤2至5，知道表达式的最右边

7.将s1中剩余的运算符依次弹出并压入s2

8.依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式



#### 代码实现



```java
public static List<String> parseSuffixExpressionList(List<String> ls){
    Stack<String> s1 = new Stack<String>();
    //s2这个栈在整个转换过程中，是不需要pop操作的，而且我们后面还要逆序输出
    // Stack<String> s2 = new Stack<String>();
    List<String> s2 = new ArrayList<String>();
    for(String item: ls){
        if(item.matches("\\d+")){	//当下一个元素为数字时
            s2.add(item);
        } else if(item.equals("(")){		//当下一个元素为左括号时
            s1.push(item);
        } else if(item.equals(")")){		//当下一个元素为右括号时
            while (!s1.peek().equals("(")){			//循环直到遇到左括号
                s2.add(s1.pop());			//将s1中的元素弹出压入s2中
            }
            s1.pop();	//弹出左括号
        } else {	//当下一个元素为运算符时
            while (s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item)){	//运算符优先级高于栈顶运算符优先级且栈不为空时
                s2.add(s1.pop());		//将s1中元素弹出并压入s2
            }
            s1.push(item);		//将该运算压入s1
        }
    }
    while (s1.size() != 0){		//将s1中剩余的运算符压入s2
        s2.add(s1.pop());
    }
    return s2;
}
```



### 完整版逆波兰计算器



```java
//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Stack;

public class hello {
    public static void main(String[] args) {
//        String suffixExpression = "4 5 * 8 - 60 + 8 2 / +";
//        //建立字符串集合对字符串进行分割
//        List<String> rpnList = getListString(suffixExpression);
//        //输出分割后的结果
//        System.out.println("rpnList = " + rpnList);
//        int res = calculate(rpnList);
//        System.out.println("计算的结果是 = " + res);


        String expression = "1+((2+3)*4)-5";
        List<String> infixExpressionList = toInfixExpressionList(expression);
        System.out.println("中缀表达式" + infixExpressionList);
        List<String> suffixExpressionList = parseSuffixExpressionList(infixExpressionList);
        System.out.println("后缀表达式为 " + suffixExpressionList);
        System.out.printf("expression=%d",calculate(suffixExpressionList));
    }

    public static List<String> parseSuffixExpressionList(List<String> ls){
    Stack<String> s1 = new Stack<String>();
    //s2这个栈在整个转换过程中，是不需要pop操作的，而且我们后面还要逆序输出
    // Stack<String> s2 = new Stack<String>();
    List<String> s2 = new ArrayList<String>();
    for(String item: ls){
        if(item.matches("\\d+")){	//当下一个元素为数字时
            s2.add(item);
        } else if(item.equals("(")){		//当下一个元素为左括号时
            s1.push(item);
        } else if(item.equals(")")){		//当下一个元素为右括号时
            while (!s1.peek().equals("(")){			//循环直到遇到左括号
                s2.add(s1.pop());			//将s1中的元素弹出压入s2中
            }
            s1.pop();	//弹出左括号
        } else {	//当下一个元素为运算符时
            while (s1.size() != 0 && Operation.getValue(s1.peek()) >= Operation.getValue(item)){	//运算符优先级高于栈顶运算符优先级且栈不为空时
                s2.add(s1.pop());		//将s1中元素弹出并压入s2
            }
            s1.push(item);		//将该运算压入s1
        }
    }
    while (s1.size() != 0){		//将s1中剩余的运算符压入s2
        s2.add(s1.pop());
    }
    return s2;
}


    public static List<String> toInfixExpressionList(String s){
        List<String> ls = new ArrayList<String>();
        int i = 0;
        String str;
        char c;
        do{			//当c不为数字
            if((c=s.charAt(i)) < 48 || (c=s.charAt(i)) > 57){
                ls.add("" + c);		//直接加入到ls中
                i++;
            } else {
                str = "";		//重置str
                while (i < s.length() && (c=s.charAt(i)) >= 48&& ((c=s.charAt(i)) <= 57)){		//当c为数字时
                    str += c;	
                    i++;
                }
                ls.add(str);	//将字符串加入到ls中
            }
        }while (i < s.length());
        return ls;
    }

    public static List<String> getListString(String suffixExpression) {
        //将字符串以空格进行分割
        String[] split = suffixExpression.split(" ");
        //建立新的字符串集合
        List<String> list = new ArrayList();
        //建立字符串数组来存储分割后的字符串
        String[] var3 = split;
        int var4 = split.length;
        //遍历数组将数组元素存入到新的链表中
        for(int var5 = 0; var5 < var4; var5++) {
            String ele = var3[var5];
            list.add(ele);
        }
        return list;
    }

    public static int calculate(List<String> ls) {
        Stack<String> stack = new Stack();	//新建栈
        Iterator var2 = ls.iterator();		//使用迭代器遍历栈

        while(var2.hasNext()) {			//var2.hasNext()当还有元素可遍历时返回true
            //item储存遍历出的数据
            String item = (String)var2.next();
            if (item.matches("\\d+")) {	//当取出的元素为数字时
                stack.push(item);	//数字入栈
            } else {		//当取出的元素为运算符时
                //弹出两个数字元素并转为整形
                int num2 = Integer.parseInt((String)stack.pop());
                int num1 = Integer.parseInt((String)stack.pop());
                int res = 0;
                if (item.equals("+")) {
                    res = num1 + num2;
                } else if (item.equals("-")) {
                    res = num1 - num2;
                } else if (item.equals("*")) {
                    res = num1 * num2;
                } else {
                    if (!item.equals("/")) {
                        throw new RuntimeException("运算符有误");
                    }
                    res = num1 / num2;
                }
                //将数字转为字符串入栈
                stack.push(res+"");
            }
        }
        //当遍历完表达式后返回最后的结果
        return Integer.parseInt((String)stack.pop());
    }
}



class Operation{

    private static int ADD = 1;
    private static int SUB = 1;
    private static int MUL = 2;
    private static int DIV = 2;

    public static int getValue(String operation){
        int res = 0;
        switch (operation){
            case "+":
                res = ADD;
                break;
            case "-":
                res = SUB;
                break;
            case "*":
                res = MUL;
                break;
            case "/":
                res = DIV;
                break;
            default:
         //       System.out.println("不存在该运算符");
                break;
        }
        return res;
    }
}
```



# 递归（Recursion）

\*\***关于递归： 一定不要试图跟踪大型递归的过程！ 要写出递归，关键就是找出递归的递归方程式： 也就是说，要完成最后一步，那么最后一步的前一步要做什么。**

## 老鼠出迷宫

```java
public class hello {
    //1为路障
    //2为移动路径
    //3为死路
    public static  void  main(String[] args){
        int [][] map = new int [8][7];
        MyTools tools = new MyTools();
        //设置地图边界
        for(int i = 0;i < 7;i++){
            map[0][i] = 1;
            map[7][i] = 1;
        }
        for(int i = 0;i < 8;i++) {
            map[i][0] = 1;
            map[i][6] = 1;
        }
        //设置路障
        map[3][2] = 1;
        map[3][1] = 1;
        map[2][2] = 1;
        map[3][3] = 1;
        //调用函数打印地图
        tools.printArr(map);
        Active t1 = new Active();
        //使用函数进行找路
        t1.findWay01(map,1,1);
        //输出找路后的地图情况
        tools.printArr(map);
        int p = 0;
        //判断是否找路成功
        t1.isOut(p);
    }
}

class Active{
    int p = 0;
    public boolean findWay01(int[][] map ,int i,int j){
        if(map[6][5]==2){
            System.out.println("Find the way!!!!");
            //找路成功及改变全局变量p
            p++;
            return true;
        }else{
            if(map[i][j]==0){

                map[i][j]=2;
                //对四个方向尝试移动
                //移动方式下-》左-》上-》右
                if(findWay01(map,i+1,j)){
                    return true;
                }else if(findWay01(map,i,j+1)) {
                    return true;
                }else if(findWay01(map,i-1,j)) {
                    return true;
                }else if(findWay01(map,i,j-1)){
                    return true;
                }
                //四个方向都无法移动代表死路
                map[i][j] = 3;
                return false;
            }else{
                return false;
            }
        }

    }

    public boolean findWay02(int[][] map ,int i,int j){
        if(map[6][5]==2){
            System.out.println("Find the way!!!!");
            //找路成功及改变全局变量p
            p++;
            return true;
        }else{
            if(map[i][j]==0){

                map[i][j]=2;
                //对四个方向尝试移动
                //移动方式上-》左-》下-》右
                if(findWay02(map,i-1,j)){
                    return true;
                }else if(findWay02(map,i,j+1)) {
                    return true;
                }else if(findWay02(map,i+1,j)) {
                    return true;
                }else if(findWay02(map,i,j-1)){
                    return true;
                }
                //四个方向都无法移动代表死路
                map[i][j] = 3;
                return false;
            }else{
                return false;
            }
        }

    }
    public void isOut(int p){
        //将全局变量p的值传递
        p = this.p;
        if(p==0){
            //p == 0代表没有一条通路
            System.out.println("can't find the way!!!");
        }
    }

}


class MyTools{
    public void printArr(int[][] map){              //打印地图
        System.out.println("==当前地图情况======");
        for(int i = 0;i < map.length;i++){
            for(int j = 0;j < map[i].length;j++){
                System.out.print(map[i][j] + " ");
            }
            System.out.println();
        }
    }
}
```



## 汉诺塔

汉诺塔移动的整个过程可看做

**把（n-1）个盘子从A通过C移动到B**

**将第n个盘子从A移动到C**

**把（n-1）个盘子从B通过A移动到C**

从而实现递归

```java
public class hello {

    public static  void  main(String[] args){
            Tower tower = new Tower();
            tower.moveLine(3,'A','B','C');

    }
}


class Tower{

    public void moveLine(int num,char a,char b,char c){
        if(num == 1){
            System.out.println(a + "->" + c);
        }else{
            moveLine(num - 1,a,c,b);
            System.out.println(a + "->" + c);
            moveLine(num - 1,b,a,c);
        }
    }

}
```



## 八皇后





```java

public class hello {

    int max = 8;
    int[] array = new int[max];
    static int count = 0;
    static int judgeCount = 0;
    public static void main(String[] args) {
        hello a = new hello();
        a.check(0);
        System.out.println(count);
        System.out.println(judgeCount);
    }

    private void check(int n){
        if(n == max){
            prinf();
            return;
        }

        for (int i = 0; i < max; i++) {
            array[n] = i;
            if(judge(n)){
                check(n+1);
            }

        }
    }

    private boolean judge(int n){
        judgeCount++;
        for(int i = 0;i < n;i++){       //判断第n个皇后是否与前面的皇后会发生攻击
            if(array[i] == array[n] || Math.abs(n-i) == Math.abs(array[n] - array[i])){
                return false;
            }
        }
        return true;
    }


    private void prinf(){
        count++;
        for(int i = 0;i < array.length;i++){
            System.out.print(array[i] + " ");
        }
        System.out.println();
    }

}
```





# 排序(Sort)

**速度测试所用数据量均为8万**

## 算法的时间复杂度

### 度量一个程序执行时间的两种方法

#### 事后统计的方法

要在同一台计算机的相同状态下运行，才能比较哪个算法更快

#### 事前估算的方法

通过分析某个算法的时间复杂度来判断哪个算法更优

### 时间频度

一个算法花费的时间与算法中语句执行的次数成正比，一个算法中的语句执行次数称为

语句频度或时间频度，记为T（n）

| 排序法 | 平均时间   | 最差情况         | 稳定度 | 额外空间 | 备注                            |
| ------ | ---------- | ---------------- | ------ | -------- | ------------------------------- |
| 冒泡   | O(n²)      | O(n²)            | 稳定   | O(1)     | n较小时好                       |
| 交换   | O(n²)      | O(n²)            | 不稳定 | O(1)     | n较小时好                       |
| 选择   | O(n²)      | O(n²)            | 不稳定 | O(1)     | n较小时好                       |
| 插入   | O(n²)      | O(n²)            | 稳定   | O(1)     | 大部分已排序时较好              |
| 基数   | O(log R B) | O(log R B)       | 稳定   | O(n)     | B是真数（0-9）R是基数（个十百） |
| 希尔   | O(nlog n)  | O(n^x)   (1<x<2) | 不稳定 | O(1)     | s是所选分组                     |
| 快速   | O(nlog n)  | O(n²)            | 不稳定 | O(nlogn) | n较大时好                       |
| 归并   | O(nlog n)  | O(nlog n)        | 稳定   | O(n)     | n较小时好                       |
| 堆     | O(nlog n)  | O(nlog n)        | 不稳定 | O(1)     | n较小时好                       |

## 冒泡排序

耗时（10s）

```java
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class hello {
    public static void main(String[] args) {
    //    int[] arr = {3,9,-1,10,20};

        int[] arr = new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int)(Math.random()*800000);
        }
     //   System.out.println(Arrays.toString(arr));

        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序开始的时间为" + date1Str);

        bubbleSort(arr);

        Date data2 = new Date();
        String date2Str = simpleDateFormat.format(data2);
        System.out.println("排序结束的时间为" + date2Str);


      //  System.out.println("最终结果");
      //  System.out.println(Arrays.toString(arr));
    }

    public static void bubbleSort(int[] arr){
        int temp = 0;
        boolean flag = false;		//当这次遍历一次没有发生数据交换时结束排序
        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if(arr[j] > arr[j + 1]){
                    flag = true;
                    temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
           // System.out.println("第" + (i + 1) + "次排序后的结果为");
          //  System.out.println(Arrays.toString(arr));
            if(!flag){
                break;
            } else {
                flag = false;
            }
        }
     //   System.out.println("最终结果");
     //   System.out.println(Arrays.toString(arr));
    }

}
```





## 选择排序

耗时（2s）短于冒泡

因为执行语句少于冒泡

```java
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class hello {
    public static void main(String[] args) {
        int[] arr = {101,34,119,1,-1,90,123};

//        int[] arr = new int[80000];
//        for (int i = 0; i < 80000; i++) {
//            arr[i] = (int)(Math.random()*800000);
//        }
     //   System.out.println(Arrays.toString(arr));

        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序开始的时间为" + date1Str);

    //    System.out.println(Arrays.toString(arr));
        selectSort(arr);

        Date data2 = new Date();
        String date2Str = simpleDateFormat.format(data2);
        System.out.println("排序结束的时间为" + date2Str);

        System.out.println("最终结果");
        System.out.println(Arrays.toString(arr));
    }

    public static void selectSort(int[] arr){
        int minIndex = 0;
        int min = arr[0];

        for (int i = 0; i < arr.length - 1; i++) {
            minIndex = i;
            min = arr[i];
            for (int j = i + 1; j < arr.length; j++) {
                if(min > arr[j]){
                    min = arr[j];
                    minIndex = j;
                }
            }

            if(minIndex != i){
                arr[minIndex] = arr[i];
                arr[i] = min;
            }

//            System.out.println("第" + (i+1) + "次循环后");
//            System.out.println(Arrays.toString(arr));
        }


    }

}
```



## 插入排序

### 算法思想

将数组看为两个部分，一部分有序，一部分无序，通过循环逐渐把无序的数据插入到有序的部分从而实现排序

### 代码实现

速度快于插入排序

用时450ms左右

```java

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class hello {
    public static void main(String[] args) {
       // int[] arr = {101,34,119,1,-1,89};

        int[] arr = new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int)(Math.random()*800000);
        }

        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序开始的时间为" + date1Str);

        insertSort(arr);
      //  System.out.println(Arrays.toString(arr));

        Date data2 = new Date();
        String date2Str = simpleDateFormat.format(data2);
        System.out.println("排序结束的时间为" + date2Str);

    }

    public static void insertSort(int[] arr){
        int insertVal = arr[1];
        int insertIndex = 0;

        for (int i = 0; i < arr.length - 1; i++) {
            insertVal = arr[i+1];		//保存插入数据的值
            insertIndex = i;			//从插入数据之前的一个位置开始寻找该插入的位置
            //寻找插入位置
            while (insertIndex >= 0 && insertVal < arr[insertIndex]){
                arr[insertIndex + 1] = arr[insertIndex];	//值覆盖只会覆盖要插入的数据
                insertIndex--;				//向前遍历
            }
            arr[insertIndex + 1] = insertVal;
     //      System.out.println("第" + (i+1) + "轮插入");
     //      System.out.println(Arrays.toString(arr));
        }

    }
}
```



## 希尔排序

### 算法思想

希尔排序为优化版的插入排序

排序的原则是将数据区分为特定间隔的几个小区块，以插入排序法对区块内的数据进行排序后，再渐渐减少间隔的距离

### 交换式

耗时5s

```java

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class hello {
    public static void main(String[] args) {
        //int[] arr = {8,9,1,7,2,3,5,4,6,0};

        int[] arr = new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int)(Math.random()*800000);
        }

        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序开始的时间为" + date1Str);

        shellsort(arr);
        //System.out.println(Arrays.toString(arr));

        Date data2 = new Date();
        String date2Str = simpleDateFormat.format(data2);
        System.out.println("排序结束的时间为" + date2Str);

    }

    public static void shellsort(int[] arr){
        int temp = 0;
        int count = 0;
        //将数据进行分块
        for(int gap = arr.length / 2;gap > 0; gap /= 2){
            //对每块的数据进行交换式的移动来排序（类似冒泡排序）
            for (int i = gap; i < arr.length; i++) {
                for (int j = i - gap; j >= 0; j -= gap) {
                    if(arr[j] > arr[j + gap]){
                        temp = arr[j];
                        arr[j] = arr[j + gap];
                        arr[j + gap] = temp;
                    }
                }
            }
           // System.out.println("第" + (++count) + "轮的结果");
          //  System.out.println(Arrays.toString(arr));
        }


    }

}
```



### 移动式

耗时40ms

```java

import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class hello {
    public static void main(String[] args) {
      //  int[] arr = {8,9,1,7,2,3,5,4,6,0};

        int[] arr = new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int)(Math.random()*800000);
        }

        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序开始的时间为" + date1Str);

        shellsort(arr);
      //  System.out.println(Arrays.toString(arr));

        Date data2 = new Date();
        String date2Str = simpleDateFormat.format(data2);
        System.out.println("排序结束的时间为" + date2Str);

    }

    public static void shellsort(int[] arr){
        int temp = 0;
        //对数据进行分块
        for(int gap = arr.length / 2;gap > 0; gap /= 2){
            //使用移动式的方法来交换数据以实现排序（类似插入排序）
            for (int i = gap; i < arr.length; i++) {
                int j = i;
                temp = arr[j];
                if(arr[j] < arr[j - gap]){
                    while (j - gap >= 0 && temp < arr[j - gap]){
                        arr[j] = arr[j - gap];
                        j -= gap;
                    }
                    arr[j] = temp;
                }
            }
        }
    }


}
```



## 快速排序

### 算法思想

快速排序是冒泡排序的优化版

先设定一个虚拟的中间值，之后将比中间值小的数据放在左边，反之放在右边，之后递归即可。

### 代码实现

耗时60ms

```java
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class hello {
    public static void main(String[] args) {
      //  int[] arr = {-9,78,0,23,-567,70,-1,900,4561};

        int[] arr = new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int)(Math.random()*800000);
        }

        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序开始的时间为" + date1Str);

        quickSort(arr,0, arr.length - 1);
   //      System.out.println(Arrays.toString(arr));

        Date data2 = new Date();
        String date2Str = simpleDateFormat.format(data2);
        System.out.println("排序结束的时间为" + date2Str);

    }


    public static void quickSort(int[] arr,int left,int right){
        int l = left;
        int r = right;
        int pivot = arr[(left + right) / 2];	//表示中间值
        int temp = 0;
        while (l < r){
            //寻找左边大于或等于pivot的数据，最后会在pivot时停下
            while (arr[l] < pivot){
                l++;
            }
            //寻找右边大于或等于pivot的数据
            while (arr[r] > pivot){
                r--;
            }
            //分类完成
            if(l >= r){
                break;
            }
			//进行值的交换
            temp = arr[l];
            arr[l] = arr[r];
            arr[r] = temp;
			//判断有与中间值相同的值时，跳过判断
            if(arr[l] == pivot){
                r--;
            }
            if(arr[r] == pivot){
                l++;
            }
        }
		//防止栈溢出
        if(l == r){
            l++;
            r--;
        }
		//对中间值左边部分进行继续排序
        if(left < r){
            quickSort(arr,left,r);
        }
		//对中间值右边部分进行继续排序
        if(right > l){
            quickSort(arr,l,right);
        }
    }

}
```



## 归并排序

### 算法思想

分而治之

先分成若干小块，之后再合并成有序的数组，整个过程可以看成一个完全的二叉树

### 代码实现

耗时30ms

```java
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class hello {
    public static void main(String[] args) {
         //   int[] arr = {8,4,5,7,1,3,6,2,0,98};

        int[] arr = new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int)(Math.random()*800000);
        }

        int[] temp = new int[arr.length];

        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序开始的时间为" + date1Str);

        mergeSort(arr,0, arr.length - 1, temp);
            System.out.println(Arrays.toString(arr));

        Date data2 = new Date();
        String date2Str = simpleDateFormat.format(data2);
        System.out.println("排序结束的时间为" + date2Str);
    }
    //分阶段
	//递归进而分块
    public static void mergeSort(int[] arr,int left,int right,int[] temp){
        if(left < right){
            int mid = (left + right) / 2;
            //向左递归以分解
            mergeSort(arr,left,mid,temp);
            //向右递归以分解
            mergeSort(arr,mid + 1,right,temp);
			//无法分解后开始“治” 
            merge(arr,left,mid,right,temp);
        }
    }
	//治阶段
	//arr表示要排序数组，left表示左边有序序列的初始索引，mid和right分别为中间和右边索引
    //temp做中转数组
	//将两小块合并为一个有序块
    public static void merge(int[] arr,int left,int mid,int right,int[] temp){
        int i = left;
        int j = mid + 1;
        int t = 0;
        //两小块都有剩余数据时
        while (i <= mid && j <= right){
            if(arr[i] <= arr[j]){
                temp[t++] = arr[i++];
            } else {
                temp[t++] = arr[j++];
            }
        }
		//第一块还有剩余数据时
        while (i <= mid){
            temp[t++] = arr[i++];
        }
		//第二块还有剩余数据时
        while (j <= right){
            temp[t++] = arr[j++];
        }
		//将数据拷贝回原先数组
        t = 0;
        int tempLeft = left;
        while (tempLeft <= right){
            arr[tempLeft++] = temp[t++];
        }

    }

}
```



## 基数排序

### 算法思想

又称桶排序

将证书按位数切割为不同的数据，从低位开始比较，位数不足为0，之后放在对应的同种，再按照这个桶的顺序输出到数组中，知道排序完成

### 代码实现

耗时35ms

```java
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;

public class hello {
    public static void main(String[] args) {
      // int[] arr = {53,3,542,748,14,214};

        int[] arr = new int[80000];
        for (int i = 0; i < 80000; i++) {
            arr[i] = (int)(Math.random()*800000);
        }

        int[] temp = new int[arr.length];

        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss:SS");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序开始的时间为" + date1Str);

        radixSort(arr);
   //     System.out.println(Arrays.toString(arr));

        Date data2 = new Date();
        String date2Str = simpleDateFormat.format(data2);
        System.out.println("排序结束的时间为" + date2Str);
    }


    public static void radixSort(int[] arr){
        //建立桶和桶的计数器
        int[][] bucket = new int[10][arr.length];
        int[] bucketElementCounts = new int[10];

        int max = arr[0];	
        for (int i = 1; i < arr.length; i++) {
            if(arr[i] > max){
                max = arr[i];
            }
        }		//获取最大数的位数
        int maxLength = (max + "").length();

        for (int i = 0,n = 1; i < maxLength; i++, n *= 10) {
            for (int j = 0; j < arr.length; j++) {
                //取当前位数
                int digitOfElement = arr[j] / n % 10;
                //将数据放入对应的桶中
                bucket[digitOfElement][bucketElementCounts[digitOfElement]++] = arr[j];
            }
            int index = 0;
            for (int k = 0; k < 10; k++) {
                if(bucketElementCounts[k] != 0){
                    for (int l = 0; l < bucketElementCounts[k]; l++) {
                        //将桶中数据取出
                        arr[index++] = bucket[k][l];
                    }
                }
                //取出后将桶的计数器重置
                bucketElementCounts[k] = 0;
            }
        }
    }

}
```



## 堆排序





### 代码实现









# 查找(Search)

## 二分查找

```java
import java.util.ArrayList;
import java.util.List;

public class hello {
    public static void main(String[] args) {
        int[] arr = {1,8,10,89,1000,1000,1000,1000,1000,1234};
        int res = binarySearch(arr,0,arr.length-1,89);
        System.out.println(res);

        List<Integer> resIndexList = binarySearch2(arr,0, arr.length - 1,1000);
        System.out.println(resIndexList);
    }
	//只有一个返回值时
    public static int binarySearch(int[] arr,int left,int right,int findVal){
        if(left > right){
            return -1;
        }
        int mid = (left + right) / 2;
        int midVal = arr[mid];
        if(findVal > midVal){	//向右递归
            return binarySearch(arr,mid + 1,right,findVal);
        } else if(findVal < midVal){	//向左递归
            return binarySearch(arr,left,mid - 1,findVal);
        } else {	//找到了
            return mid;
        }
    }
	//有多个返回值时，将返回值存入到集合中
    public static ArrayList<Integer> binarySearch2(int[] arr, int left, int right, int findVal){
        if(left > right){
            return new ArrayList<Integer>();
        }
        int mid = (left + right) / 2;
        int midVal = arr[mid];
        if(findVal > midVal){
            return binarySearch2(arr,mid + 1,right,findVal);
        } else if(findVal < midVal){
            return binarySearch2(arr,left,mid - 1,findVal);
        } else {
            ArrayList<Integer> resIndexlist = new ArrayList<Integer>();
            int temp = mid - 1;
            while (true){
                if(temp < 0 || arr[temp] != findVal){
                    break;
                }
                resIndexlist.add(temp);
                temp--;
            }
            resIndexlist.add(mid);
            temp = mid + 1;
            while (true){
                if(temp >= arr.length || arr[temp] != findVal){
                    break;
                }
                resIndexlist.add(temp);
                temp++;
            }
            return resIndexlist;
        }
    }


}
```



## 插值查找

数据分布均匀时，效率高于二分查找

当数据分布不均匀时，效率不一定高于二分查找

优化在mid的值的选取上

```java
public class hello {
    public static void main(String[] args) {
        int[] arr = new int[100];
        for (int i = 0; i < 100; i++) {
            arr[i] = i + 1;
        }

        int res = binarySearch(arr,0,arr.length-1,100);
        int res2 = insertValueSearch(arr,0,arr.length - 1,100);
        System.out.println(res);
        System.out.println(res2);

    }

    public static int binarySearch(int[] arr,int left,int right,int findVal){
        System.out.println("HEllo");
        if(left > right){
            return -1;
        }
        int mid = (left + right) / 2;
        int midVal = arr[mid];
        if(findVal > midVal){
            return binarySearch(arr,mid + 1,right,findVal);
        } else if(findVal < midVal){
            return binarySearch(arr,left,mid - 1,findVal);
        } else {
            return mid;
        }
    }


    public static int insertValueSearch(int[] arr,int left,int right,int findVal){
        System.out.println("PPPPP");
        //多两个判断条件，防止后面mid越界
        if(left > right || findVal < arr[0] || findVal > arr[arr.length - 1]){
            return -1;
        }		
        //优化mid的值
        int mid = left + (right - left) * (findVal - arr[left]) / (arr[right] - arr[left]);
        int midVal = arr[mid];
        if(findVal > midVal){
            return insertValueSearch(arr,mid + 1,right,findVal);
        } else if(findVal < midVal){
            return insertValueSearch(arr,left,mid - 1,findVal);
        } else {
            return mid;
        }
    }


}
```



## 斐波那契查找

借助斐波那契数列来判定查找范围

![image-20221031202711478](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\image-20221031202711478.png)

```java
import java.util.Arrays;

public class hello {

    public static int maxSize = 20;
    public static void main(String[] args) {
        int[] arr = {1,8,10,89,1000,1234};
        System.out.println(fibonacciSearch(arr,819));

    }


    public static int[] fib(){
        int[] f = new int[maxSize];
        f[0] = 1;
        f[1] = 1;
        for(int i = 2;i < maxSize;i++){
            f[i] = f[i-1] + f[i-2];
        }
        return f;
    }

    public static int fibonacciSearch(int[] arr,int key){
        int low = 0;
        int high = arr.length - 1;
        int k = 0;
        int mid = 0;
        int f[] = fib();
        while (high > f[k] - 1){
            k++;
        }
        int[] temp = Arrays.copyOf(arr,f[k]);
        for (int i = high + 1; i < temp.length; i++) {
            temp[i] = arr[high];
        }
        while (low <= high){ 
            //f[k]表示整个查找的范围
            mid = low + f[k - 1] - 1;
            if(key < temp[mid]){	//在中间值的左边，故搜索范围只有f[k-1]
                high = mid - 1;
                k--;
            } else if(key > temp[mid]){	//在中间值的右边边，故搜索范围只有f[k-2]
                low = mid + 1;
                k-=2;
            } else {
                if(mid <= high){
                    return mid;
                } else {
                    return high;		//寻找到了数组扩容的区域
                }
            }
        }
        return -1;
    }
}
```



# 哈希表(Hash Table)



```java
import java.util.Scanner;

public class hello {
    public static void main(String[] args) {
        HashTab hashTab = new HashTab(7);		//创建由7条链表组成的散列表
        String key = "";
        Scanner scanner = new Scanner(System.in);
        while (true){
            System.out.println("add： 添加雇员");
            System.out.println("list： 显示雇员");
            System.out.println("find： 查找雇员");
            System.out.println("exit： 退出系统");

            key = scanner.next();
            switch (key){
                case "add":
                    System.out.println("输入id");
                    int id = scanner.nextInt();
                    System.out.println("输入名字");
                    String name = scanner.next();
                    Emp emp = new Emp(id,name);
                    hashTab.add(emp);
                    break;
                case "list":
                    hashTab.list();
                    break;
                case "find":
                    System.out.println("请输入要查找的id");
                    id = scanner.nextInt();
                    hashTab.findEmpById(id);
                    break;
                case "exit":
                    scanner.close();
                    System.exit(0);
                    break;
                default:
                    break;
            }
        }
        
    }
}


class Emp{		//雇员链表结点
    public int id;
    public String name;
    public Emp next;
    public Emp(int id,String name){
        super();
        this.id = id;
        this.name = name;
    }
}


class EmpLinkedList{		//雇员链表对象
     private Emp head;
		//尾接法
     public void add(Emp emp){
         if(head == null){		//链表为空时
             head = emp;
             return;
         }
         Emp curEmp = head;
         while (true){
             if(curEmp.next == null){		//找到插入位置
                 break;
             }
             curEmp = curEmp.next;
         }
         curEmp.next = emp;			//挂链
     }
		//遍历链表
     public void list(int no){
         if(head == null){
             System.out.println("第" + (no+1) + "条链表为空");
             return;
         }
         Emp curEmp = head;
         System.out.print("第" + (no+1) + "条链表信息为");
         while (true){
             System.out.printf("=> id = %d name = %s\t",curEmp.id,curEmp.name);
             if(curEmp.next == null){
                 break;
             }
             curEmp = curEmp.next;
         }
         System.out.println();
     }
		//寻找节点
     public Emp fineEmpById(int id){
         if(head == null){
             System.out.println("链表为空");
             return null;
         }
         Emp curEmp = head;
         while (true){
             if(curEmp.id == id){
                 break;
             }
             if(curEmp.next == null){
                 curEmp = null;
                 break;
             }
             curEmp = curEmp.next;
         }
         return curEmp;
     }
}


class HashTab{
    private  EmpLinkedList[] empLinkedListsArray;	//创建链表数组
    private int size;					//设定数组大小
    public HashTab(int size){	//size表示构造几个链表
        this.size = size;
        empLinkedListsArray = new EmpLinkedList[size];		//分配空间
        for (int i = 0; i < size; i++) {
            empLinkedListsArray[i] = new EmpLinkedList();	
        }
    }

    public void add(Emp emp){		//添加雇员
        int empLinkedListNo = hashFun(emp.id);		//判断该雇员存放在第几条链表	
        empLinkedListsArray[empLinkedListNo].add(emp);		//将雇员加入链表

    }

    public void list(){			//遍历
        for (int i = 0; i < size; i++) {
            empLinkedListsArray[i].list(i);
        }
    }

    public void findEmpById(int id){		//查找雇员
        int empLinkedListNo = hashFun(id);
        Emp emp = empLinkedListsArray[empLinkedListNo].fineEmpById(id);
        if(emp != null){
            System.out.printf("在第%d条链表中找到雇员 id = %d\n",empLinkedListNo+1,id);
        } else {
           System.out.println("没有找到该雇员");
        }
    }
		//判断该雇员存放在第几条链表
    public int hashFun(int id){
        return id % size;
    }

}
```



# 树(Tree)

## 二叉树

### 二叉树的遍历

#### 前序遍历

先输出父节点，再遍历左子树和右子树

#### 中序遍历

先遍历左子树，再输出父节点，再遍历右子树

#### 后序遍历

先遍历左子树，再遍历右子树，最后输出父节点



#### 代码实现

```java
public class hello {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();

        HeroNode root = new HeroNode(1,"宋江");
        HeroNode node2 = new HeroNode(2,"吴用");
        HeroNode node3 = new HeroNode(3,"卢俊义");
        HeroNode node4 = new HeroNode(4,"林冲");
        HeroNode node5 = new HeroNode(5,"关胜");

        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);

        binaryTree.setRoot(root);
    //    binaryTree.preOrder();
    //    binaryTree.infixOrder();
        binaryTree.postOrder();
    }
}

class BinaryTree{
    private HeroNode root;

    public void setRoot(HeroNode root){
        this.root = root;		//设置根结点
    }

    public void preOrder(){		//前序遍历
        if(this.root != null){
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    public void infixOrder(){		//中序遍历
        if(this.root != null){
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    public void postOrder(){		//后序遍历
        if(this.root != null){
            this.root.postOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
}





class HeroNode{
    private int no;
    private String name;
    private HeroNode left;		//左子节点
    private HeroNode right;		//右子节点
    public HeroNode(int no, String name) {		//构造器用于初始化
        this.no = no;			
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    //重写tostring
    @Override
    public String toString() {
        return "HeroNode{" + "no=" + no + ", name='" + name + '\'' + '}';
    }

    public void preOrder(){		//前序遍历
        System.out.println(this);		//输出当前结点
        if(this.left != null){			
            this.left.preOrder();		//向左遍历
        }

        if(this.right != null){
            this.right.preOrder();		//向右遍历
        }
    }

    public void infixOrder(){	//中序遍历
        if(this.left != null){
            this.left.infixOrder();		//向左遍历
        }

        System.out.println(this);		//输出当前结点

        if(this.right != null){
            this.right.infixOrder();		//向右遍历
        }
    }

    public void postOrder(){	//后序遍历哦
        if(this.left != null){
            this.left.postOrder();		//向左遍历
        }

        if(this.right != null){
            this.right.postOrder();		//向右遍历
        }

        System.out.println(this);		//输出当前结点
    }
}
```



### 二叉树的查找

前序中序后序与遍历相同，找到值返回即可

#### 代码实现

```java
public class hello {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();

        HeroNode root = new HeroNode(1,"宋江");
        HeroNode node2 = new HeroNode(2,"吴用");
        HeroNode node3 = new HeroNode(3,"卢俊义");
        HeroNode node4 = new HeroNode(4,"林冲");
        HeroNode node5 = new HeroNode(5,"关胜");

        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);

        binaryTree.setRoot(root);
    //    binaryTree.preOrder();
    //    binaryTree.infixOrder();
    //   binaryTree.postOrder();
        HeroNode resNode = binaryTree.postOrderSearch(5);
        if(resNode != null){
            System.out.println(resNode);
        } else {
            System.out.println("Not found");
        }
    }
}


class BinaryTree{
    private HeroNode root;

    public void setRoot(HeroNode root){
        this.root = root;
    }

    public void preOrder(){
        if(this.root != null){
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    public void infixOrder(){
        if(this.root != null){
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    public void postOrder(){
        if(this.root != null){
            this.root.postOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    public HeroNode preOrderSearch(int no){
        if(root != null){
            return root.preOrderSearch(no);
        } else {
            return null;
        }
    }

    public HeroNode infixOrderSearch(int no){
        if(root != null){
            return root.infixOrderSearch(no);
        } else {
            return null;
        }
    }

    public HeroNode postOrderSearch(int no){
        if(root != null){
            return root.postOrderSearch(no);
        } else {
            return null;
        }
    }
}



class HeroNode{
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;
    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" + "no=" + no + ", name='" + name + '\'' + '}';
    }

    public void preOrder(){
        System.out.println(this);
        if(this.left != null){
            this.left.preOrder();
        }
        if(this.right != null){
            this.right.preOrder();
        }
    }

    public void infixOrder(){
        if(this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right != null){
            this.right.infixOrder();
        }
    }

    public void postOrder(){
        if(this.left != null){
            this.left.postOrder();
        }
        if(this.right != null){
            this.right.postOrder();
        }
        System.out.println(this);
    }

    public HeroNode preOrderSearch(int no){
        if(this.no == no){
            return this;		//相同则直接返回
        }
        HeroNode resNode = null;		//新建辅助结点
        if(this.left != null){		
            resNode = this.left.preOrderSearch(no);		//向左遍历
        }
        if(resNode != null){		//不为空则代表以找到相同值
            return resNode;
        }
        if(this.right != null){		
            resNode = this.right.preOrderSearch(no);		//向右遍历
        }
        return resNode;				//遍历完成直接返回节点，没有找到则结点为空
    }

    public HeroNode infixOrderSearch(int no){
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.infixOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.no == no){
            return this;
        }
        if(this.right != null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;
    }

    public HeroNode postOrderSearch(int no){
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.postOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.right != null){
            resNode = this.right.postOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.no == no){
            return this;
        }
        return resNode;
    }
    
}
```





### 二叉树的删除

如果该结点是叶子结点，则删除该结点

如果该结点是非叶子结点，则删除该子树

#### 代码实现

```java
public class hello {
    public static void main(String[] args) {
        BinaryTree binaryTree = new BinaryTree();

        HeroNode root = new HeroNode(1,"宋江");
        HeroNode node2 = new HeroNode(2,"吴用");
        HeroNode node3 = new HeroNode(3,"卢俊义");
        HeroNode node4 = new HeroNode(4,"林冲");
        HeroNode node5 = new HeroNode(5,"关胜");

        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);

        binaryTree.setRoot(root);

        binaryTree.preOrder();
        binaryTree.delNode(4);
        System.out.println("=============================");
        binaryTree.preOrder();

    }
}


class BinaryTree{
    private HeroNode root;

    public void setRoot(HeroNode root){
        this.root = root;
    }

    public void delNode(int no){
        if(root != null){
            if(root.getNo() == no){
                root = null;
            } else {
                root.delNode(no);
            }
        } else {
            System.out.println("空树");
        }
    }

    public void preOrder(){
        if(this.root != null){
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

}





class HeroNode{
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;
    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    @Override
    public String toString() {
        return "HeroNode{" + "no=" + no + ", name='" + name + '\'' + '}';
    }

    public void preOrder(){
        System.out.println(this);
        if(this.left != null){
            this.left.preOrder();
        }
        if(this.right != null){
            this.right.preOrder();
        }
    }

    public void delNode(int no){
        if(this.left != null && this.left.no == no){		//找到结点则直接删除
            this.left = null;
            return;
        }

        if(this.right != null && this.right.no == no){
            this.right = null;
            return;
        }
		//没有找到则继续遍历
        if(this.left != null){		
            this.left.delNode(no);
        }

        if(this.right != null){
            this.right.delNode(no);
        }

    }

}
```





### 二叉树的顺序存储

将数组转化为二叉树的前序输出



#### 代码实现

```java
public class hello {
    public static void main(String[] args) {
        int[] arr = {1,2,3,4,5,6,7};
        ArrayBinaryTree arrayBinaryTree = new ArrayBinaryTree(arr);
        arrayBinaryTree.preOrder(0);
    }
}

class ArrayBinaryTree{
    private int[] arr;

    public ArrayBinaryTree(int[] arr){
        this.arr = arr;
    }

    public void preOrder(){
        this.preOrder(0);
    }

    public void preOrder(int index){		//使用递归将二叉树存储到数组中
        if(arr == null || arr.length == 0){
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }

        System.out.println(arr[index]);

        if((index * 2 + 1) < arr.length){
            preOrder(2 * index + 1);
        }

        if((index * 2 + 2) < arr.length){
            preOrder(2 * index + 2);
        }

    }




}
```





### 线索化二叉树

线索化即将叶子结点没有利用的左右指针分别指向该结点的前驱结点和后继结点



#### 代码实现

```java
public class hello {
    public static void main(String[] args) {

        HeroNode root = new HeroNode(1,"Tom");
        HeroNode node2 = new HeroNode(3,"Jack");
        HeroNode node3 = new HeroNode(6,"Smith");
        HeroNode node4 = new HeroNode(8,"Mary");
        HeroNode node5 = new HeroNode(10,"King");
        HeroNode node6 = new HeroNode(14,"Dim");

        root.setLeft(node2);
        root.setRight(node3);
        node2.setLeft(node4);
        node2.setRight(node5);
        node3.setLeft(node6);

        BinaryTree binaryTree = new BinaryTree();
        binaryTree.setRoot(root);
        binaryTree.threadedNodes();

        HeroNode leftNode = node5.getLeft();
        HeroNode rightNode = node5.getRight();
        System.out.println(leftNode);
        System.out.println(rightNode);
    }
}



class BinaryTree{
    private HeroNode root;
    private HeroNode pre = null;

    public void setRoot(HeroNode root){
        this.root = root;
    }

    public void threadedNodes(){
        this.threadedNodes(root);
    }

    public void threadedNodes(HeroNode node){

        if(node == null){
            return;
        }

        threadedNodes(node.getLeft());

        if(node.getLeft() == null){
            node.setLeft(pre);
            node.setLeftType(1);
        }

        if(pre != null && pre.getRight() == null){
            pre.setRight(node);
            pre.setRightType(1);
        }

        pre = node;

        threadedNodes(node.getRight());


    }
    
}




class HeroNode{
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    private int leftType;
    private int rightType;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    @Override
    public String toString() {
        return "HeroNode{" + "no=" + no + ", name='" + name + '\'' + '}';
    }
    
}
```



#### 线索化遍历二叉树

```java
public class hello {
    public static void main(String[] args) {

        HeroNode root = new HeroNode(1,"Tom");
        HeroNode node2 = new HeroNode(3,"Jack");
        HeroNode node3 = new HeroNode(6,"Smith");
        HeroNode node4 = new HeroNode(8,"Mary");
        HeroNode node5 = new HeroNode(10,"King");
        HeroNode node6 = new HeroNode(14,"Dim");

        root.setLeft(node2);        //              root
        root.setRight(node3);       //             ↙     ↘
        node2.setLeft(node4);       //          node2   node3
        node2.setRight(node5);      //          ↙   ↘       ↘
        node3.setLeft(node6);       //      node4  node5    node6

        BinaryTree binaryTree = new BinaryTree();
        binaryTree.setRoot(root);
        binaryTree.threadedNodes();

        HeroNode leftNode = node5.getLeft();
        HeroNode rightNode = node5.getRight();
    //    System.out.println(leftNode);
    //    System.out.println(rightNode);

        binaryTree.threadedList();

    }
}



class BinaryTree{
    private HeroNode root;
    private HeroNode pre = null;

    public void setRoot(HeroNode root){
        this.root = root;
    }

    public void threadedNodes(){
        this.threadedNodes(root);
    }

    public void threadedList(){
        HeroNode node = root;
        while (node != null){
            while (node.getLeftType() == 0){
                node = node.getLeft();
            }

            System.out.println(node);
            while (node.getRightType() == 1){
                node = node.getRight();
                System.out.println(node);
            }

            node = node.getRight();
        }
    }

    public void threadedNodes(HeroNode node){

        if(node == null){
            return;
        }

        threadedNodes(node.getLeft());

        if(node.getLeft() == null){
            node.setLeft(pre);
            node.setLeftType(1);
        }

        if(pre != null && pre.getRight() == null){
            pre.setRight(node);
            pre.setRightType(1);
        }

        pre = node;

        threadedNodes(node.getRight());


    }


    public void delNode(int no){
        if(root != null){
            if(root.getNo() == no){
                root = null;
            } else {
                root.delNode(no);
            }
        } else {
            System.out.println("空树");
        }
    }

    public void preOrder(){
        if(this.root != null){
            this.root.preOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    public void infixOrder(){
        if(this.root != null){
            this.root.infixOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    public void postOrder(){
        if(this.root != null){
            this.root.postOrder();
        } else {
            System.out.println("二叉树为空，无法遍历");
        }
    }

    public HeroNode preOrderSearch(int no){
        if(root != null){
            return root.preOrderSearch(no);
        } else {
            return null;
        }
    }

    public HeroNode infixOrderSearch(int no){
        if(root != null){
            return root.infixOrderSearch(no);
        } else {
            return null;
        }
    }

    public HeroNode postOrderSearch(int no){
        if(root != null){
            return root.postOrderSearch(no);
        } else {
            return null;
        }
    }
}




class HeroNode{
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;

    private int leftType;
    private int rightType;

    public HeroNode(int no, String name) {
        this.no = no;
        this.name = name;
    }

    public int getNo() {
        return no;
    }

    public void setNo(int no) {
        this.no = no;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }

    public int getLeftType() {
        return leftType;
    }

    public void setLeftType(int leftType) {
        this.leftType = leftType;
    }

    public int getRightType() {
        return rightType;
    }

    public void setRightType(int rightType) {
        this.rightType = rightType;
    }

    @Override
    public String toString() {
        return "HeroNode{" + "no=" + no + ", name='" + name + '\'' + '}';
    }

    public void preOrder(){
        System.out.println(this);
        if(this.left != null){
            this.left.preOrder();
        }
        if(this.right != null){
            this.right.preOrder();
        }
    }

    public void infixOrder(){
        if(this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right != null){
            this.right.infixOrder();
        }
    }

    public void postOrder(){
        if(this.left != null){
            this.left.postOrder();
        }
        if(this.right != null){
            this.right.postOrder();
        }
        System.out.println(this);
    }

    public HeroNode preOrderSearch(int no){
        if(this.no == no){
            return this;
        }
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;
    }

    public HeroNode infixOrderSearch(int no){
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.infixOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.no == no){
            return this;
        }
        if(this.right != null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;
    }

    public HeroNode postOrderSearch(int no){
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.postOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.right != null){
            resNode = this.right.postOrderSearch(no);
        }
        if(resNode != null){
            return resNode;
        }
        if(this.no == no){
            return this;
        }
        return resNode;
    }

    public void delNode(int no){
        if(this.left != null && this.left.no == no){
            this.left = null;
            return;
        }

        if(this.right != null && this.right.no == no){
            this.right = null;
            return;
        }

        if(this.left != null){
            this.left.delNode(no);
        }

        if(this.right != null){
            this.right.delNode(no);
        }

    }

}
```



## 赫夫曼树

### 基本介绍

给定n个权值作为n个叶子结点，构造一棵二叉树，若该树的带权路径长度（wlp）达到最小，

称这样的二叉树为最优二叉树，也成为哈夫曼树

赫夫曼树是带权路径长度最短的树，权值较大的系欸但离根较进

带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积

树的带权路径长度为所有叶子结点的带权路径长度之和

### 代码实现

```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class hello {
    public static void main(String[] args) {
        int[] arr = {13,7,8,3,29,6,1};
        Node root = createHuffmanTree(arr);     //将arr传入构建赫夫曼树
        preOrder(root);             //前序遍历
    }

    public static void preOrder(Node root){
        if(root != null){
            root.preOrder();
        } else {
            System.out.println("空树");
        }
    }

    public static Node createHuffmanTree(int[] arr){
        List<Node> nodes = new ArrayList<Node>();       //建立集合存储节点
        for(int value : arr){
            nodes.add(new Node(value));         //根据arr中的值创建节点并加入到集合
        }
        Collections.sort(nodes);        //对该集合进行排序
        //  System.out.println("node = " + nodes);
        while (nodes.size() > 1){       //如果集合内的元素大于1
            Node leftNode = nodes.get(0);       //新建左右两个节点的值为前两个节点
            Node rightNode = nodes.get(1);

            Node parent = new Node(leftNode.value + rightNode.value);       //新建一个节点并且左右指向之前创建的节点
            parent.left = leftNode;
            parent.right = rightNode;

            nodes.remove(leftNode);     //将两个创建的节点移除
            nodes.remove(rightNode);      
            nodes.add(parent);       //新节点加入集合

            Collections.sort(nodes);        //重新排序
            //      System.out.println("node = " + nodes);
        }

        return nodes.get(0);        //返回最后的节点
    }
}


class Node implements Comparable<Node>{
    int value;      //权值
    Node left;
    Node right;

    public void preOrder(){         //前序遍历
        System.out.println(this);
        if(this.left != null){
            this.left.preOrder();
        }
        if(this.right != null){
            this.right.preOrder();
        }
    }

    public Node(int value){ 
        this.value = value;
    }

    @Override
    public String toString() {
        return "Node{" + "value=" + value + '}';
    }

    @Override
    public int compareTo(Node o) {          //重写compareTo使其可以从小到大排列
        return this.value - o.value;
    }
}
```



## 赫夫曼编码

### 解压缩字符串

```java
import java.util.*;

public class hello {
    public static void main(String[] args) {
        String content = "i like like like java do you like a java";
        byte[] contentBytes = content.getBytes();   //创建byte数组存放字符串
        System.out.println(contentBytes.length);
        //存储赫夫曼编码
        byte[] huffmanCodeBytes = huffmanZip(contentBytes);
    //    System.out.println("zipped result = " + Arrays.toString(huffmanCodeBytes));
    //    System.out.println("length = " + huffmanCodeBytes.length);

    //    System.out.println(byteToBitString(true , (byte) 4));
        byte[] sourceBytes = decode(huffmanCodes,huffmanCodeBytes);     //解压
        System.out.println("sourceBytes = " + new String(sourceBytes));

    }

    private static byte[] decode(Map<Byte,String> huffmanCodes,byte[] huffmanBytes) {
        StringBuilder stringBuilder = new StringBuilder();
        //将byte数组转化位二进制字符串
        for (int i = 0; i < huffmanBytes.length; i++) {
            byte b = huffmanBytes[i];
            boolean flag = (i == huffmanBytes.length - 1);
            stringBuilder.append(byteToBitString(!flag,b));
        }
        System.out.println("byte[] to binaryString = " + stringBuilder.toString());
        //新建Map存放数据，使用Entry类构成单向链表来存放huffman表
        Map<String,Byte> map = new HashMap<String,Byte>();
        for(Map.Entry<Byte,String> entry: huffmanCodes.entrySet()) {
            map.put(entry.getValue(),entry.getKey());
        }
        System.out.println("map = " + map);
        //通过查表来解压
        List<Byte> list = new ArrayList<>();
        for(int i = 0;i < stringBuilder.length(); ) {
            int count = 1;
            boolean flag = true;
            Byte b = null;

            while (flag) {
                String key = stringBuilder.substring(i, i+count);
                b = map.get(key);
                if(b == null) { //判断是否匹配成功
                    count++;
                } else {
                    flag = false;
                }
            }
            list.add(b);       //将解压后的数据存放到list中
            i += count;
        }
        byte b[] = new byte[list.size()];
        for (int i = 0; i < b.length; i++) {    //将list转化位byte数组
            b[i] = list.get(i);
        }
        return b;
    }


    //flag表示是否需要补高位
    private static String byteToBitString(boolean flag , byte b) {
        int temp = b;
        if(flag) {      //正数需要补高位
            temp |=256;
        }
        String str = Integer.toBinaryString(temp);
     //   System.out.println("str = " + str);

        if(flag) {
            return str.substring(str.length() - 8);
        } else {
            return str;
        }

    }


    private static byte[] huffmanZip(byte[] bytes) {
        //创建集合存储元素
        List<Node> nodes = getNodes(bytes);
        //建立huffman树
        Node huffmanTree = createHuffmanTree(nodes);
        //获取huffman编码表
        Map<Byte, String > huffmanCodes = getCodes(huffmanTree);
        //取得经过压缩的字符串
        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);

        return huffmanCodeBytes;
    }
    //返回通过huffmanCode压缩后的字符串
    private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {
        StringBuilder stringBuilder = new StringBuilder();
        for(byte b : bytes) {      //将原先的字符串进行压缩
            stringBuilder.append(huffmanCodes.get(b));      //此时编码为二进制编码
        }
    //    System.out.println("Test = " + stringBuilder.toString());
        int len;
    //    int len = (stringBuilder.length() + 7) / 8;
        //统计返回byte数组的长度
        if(stringBuilder.length() % 8 == 0) {
            len = stringBuilder.length() / 8;
        } else {
            len = stringBuilder.length() / 8 + 1;
        }
        //创建存储压缩后的byte数组
        byte[] huffmanCodeBytes = new byte[len];
        int index = 0;      //计数器，记录当前加入的是第几个byte
        for (int i = 0; i < stringBuilder.length(); i += 8) {   //byte占1个字节，8位二进制数
            String strByte;
            //防止字符串长度不可以被8整除而可能会发生的数组越界
            if(i + 8 > stringBuilder.length()) {
                strByte = stringBuilder.substring(i);               //取从第i位开始后的全部数据
            } else {
                strByte = stringBuilder.substring(i, i + 8);        //从i取到i+8
            }
            //将steByte转换位byte，放入返回数组中
            huffmanCodeBytes[index] = (byte)Integer.parseInt(strByte, 2);
            index++;
        }
        return huffmanCodeBytes;        //返回byte数组
    }

    static Map<Byte, String> huffmanCodes = new HashMap<Byte, String >();

    static StringBuilder stringBuilder = new StringBuilder();

    private static Map<Byte, String> getCodes(Node root) {      //getCodes方法重载方便调用
        if(root == null) {
            return null;
        }
        getCodes(root.left,"0",stringBuilder);
        getCodes(root.right,"1",stringBuilder);
        return huffmanCodes;
    }

    //node为传入结点     code为路径     stringBuilder用于拼接路径
    private static void getCodes(Node node, String code, StringBuilder stringBuilder) {
        //实例化StringBuilder对象，并给stringBuilder2赋初值，以实现编码（路径）的保存
        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
        stringBuilder2.append(code);            //添加走到该节点的最后一步路径
        if(node != null) {
            if(node.data == null) { //分别向左右遍历
                getCodes(node.left,"0",stringBuilder2);
                getCodes(node.right,"1",stringBuilder2);
            } else {
                //Map对象的put方法，及存放该结点的数据及他的拼接路径
                huffmanCodes.put(node.data, stringBuilder2.toString());
            }
        }
    }

    private static List<Node> getNodes(byte[] bytes) {
        ArrayList<Node> nodes = new ArrayList<Node>();

        Map<Byte,Integer> counts = new HashMap();

        for(byte b : bytes) {
            Integer count = counts.get(b);
            if(count == null) {
                counts.put(b,1);
            } else {
                counts.put(b,count + 1);
            }
        }

        for(Map.Entry<Byte,Integer> entry : counts.entrySet()) {
            nodes.add(new Node(entry.getKey(),entry.getValue()));
        }
        return nodes;
    }

    private static Node createHuffmanTree(List<Node> nodes) {
        while (nodes.size() > 1) {      //当集合中的元素大于1
            Collections.sort(nodes);       //huffman树的构建过程
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            Node parent = new Node(null, leftNode.weight + rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;

            nodes.remove(leftNode);     //移除结点
            nodes.remove(rightNode);

            nodes.add(parent);      //添加处理好的结点
        }

        return nodes.get(0);        //返回huffman树的根结点
    }
}

//实现comparable接口以方便排序
class Node implements Comparable<Node>{
    Byte data;      //数据
    int weight;     //权重
    Node left;      //左右指针
    Node right;

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override       //重写compareTo便于结点排序
    public int compareTo(Node o) {
        return this.weight - o.weight;
    }

    @Override       //重写toString
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }
    //前序遍历
    public void preOrder() {
        System.out.println(this);
        if(this.left != null) {
            this.left.preOrder();
        }
        if(this.right != null) {
            this.right.preOrder();
        }
    }
}
```



### 解压缩文件

```java
import java.io.*;
import java.util.*;

public class hello {
    public static void main(String[] args) {
//        String content = "i like like like java do you like a java";
//        byte[] contentBytes = content.getBytes();   //创建byte数组存放字符串
//        System.out.println(contentBytes.length);
//        //存储赫夫曼编码
//        byte[] huffmanCodeBytes = huffmanZip(contentBytes);
//    //    System.out.println("zipped result = " + Arrays.toString(huffmanCodeBytes));
//    //    System.out.println("length = " + huffmanCodeBytes.length);
//
//    //    System.out.println(byteToBitString(true , (byte) 4));
//        byte[] sourceBytes = decode(huffmanCodes,huffmanCodeBytes);     //解压
//        System.out.println("sourceBytes = " + new String(sourceBytes));

        //文件压缩
//        String srcFile = "d://Desktop//ww.jpg";
//        String dstFile = "d://Desktop//dst22.zip";
//        zipFile(srcFile,dstFile);
//        System.out.println("OK");
        //文件解压
        String zipFile = "d://Desktop//dst22.zip";
        String dstFile = "d://Desktop//weee.jpg";   //byte[] to binaryString = 0101110111101010100
        unZipFile(zipFile, dstFile);                                   //  Test =01011101111010100100
        System.out.println("OK");


    }

    //
    public static void unZipFile(String zipFile, String dstFile) {
        //定义文件输入流
        InputStream is = null;
        //定义一个对象的输入流
        ObjectInputStream ois = null;
        //定义文件输出流
        OutputStream os = null;

        try {
            //创建文件输入流
            is = new FileInputStream(zipFile);
            //创建一个和is相关的对象输入流
            ois = new ObjectInputStream(is);
            //读取byte数组 huffmanBytes
            byte[] huffmanBytes = (byte[]) ois.readObject();
            //读取huffman编码表
            Map<Byte, String> huffmanCodes = (Map<Byte, String>) ois.readObject();
            //解码
            byte[] bytes = decode(huffmanCodes, huffmanBytes);
            //将bytes数组写入目标文件
            os = new FileOutputStream(dstFile);
            //写数据到dstFile中
            os.write(bytes);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        } finally {
            try {
                os.close();
                ois.close();
                is.close();
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }
        }


    }


    //srcFile为希望压缩文件的全路径，dstFile为压缩文件的目录
    public static void zipFile(String srcFile, String dstFile) {     //文件的压缩
        //创建输出流
        OutputStream os = null;
        ObjectOutputStream oos = null;
        //创建输入流
        FileInputStream is = null;
        try {
            //创建文件输入流
            is = new FileInputStream(srcFile);
            //创建一个和源文件大小一样的byte[]
            byte[] b = new byte[is.available() + 1];
            b[b.length - 1] = ' ';
            is.read(b);     //读取文件
            //对源文件压缩
            byte[] huffmanBytes = huffmanZip(b);
            //创建文件输出流，存放压缩文件
            os = new FileOutputStream(dstFile);
            //创建一个和文件输出流相关的ObjectOutputStream
            oos = new ObjectOutputStream(os);
            //把huffman编码后的字节数组写入压缩文件
            oos.writeObject(huffmanBytes);
            //写入huffman编码
            oos.writeObject(huffmanCodes);

        } catch (Exception e) {
            System.out.println(e.getMessage());
        } finally {
            try {
                is.close();
                oos.close();
                os.close();
            } catch (Exception e) {
                System.out.println(e.getMessage());
            }

        }

    }


    private static byte[] decode(Map<Byte, String> huffmanCodes, byte[] huffmanBytes) {

        StringBuilder stringBuilder = new StringBuilder();
        //将byte数组转化位二进制字符串
        for (int i = 0; i < huffmanBytes.length; i++) {
            byte b = huffmanBytes[i];
            boolean flag = (i == huffmanBytes.length - 1);
            stringBuilder.append(byteToBitString(!flag, b));
        }
        //System.out.println("byte[] to binaryString = " + stringBuilder.toString());
        //新建Map存放数据，使用Entry类构成单向链表来存放huffman表
        Map<String, Byte> map = new HashMap<String, Byte>();
        for (Map.Entry<Byte, String> entry : huffmanCodes.entrySet()) {
            map.put(entry.getValue(), entry.getKey());
        }

        //    System.out.println("map = " + map);
        //通过查表来解压
        List<Byte> list = new ArrayList<>();
        for (int i = 0; i < stringBuilder.length(); ) {
            int count = 1;
            boolean flag = true;
            Byte b = null;
        //    System.out.println(stringBuilder.length() - i - 1);
            while (flag) {
                String key = null;
                key = stringBuilder.substring(i, i + count);
                if (count > 100) {
                    break;
                }
                b = map.get(key);
                if (b == null) { //判断是否匹配成功
                    count++;
                } else {
                    flag = false;
                }

            }

            list.add(b);       //将解压后的数据存放到list中
            i += count;
            if (i >= stringBuilder.length() - 1) {
                break;
            }
        }

        byte b[] = new byte[list.size() - 1];
        for (int i = 0; i < b.length - 1; i++) {    //将list转化位byte数组
            b[i] = list.get(i);
        }
        return b;
    }


    //flag表示是否需要补高位
    private static String byteToBitString(boolean flag, byte b) {
        int temp = b;
        if (flag) {      //正数需要补高位
            temp |= 256;
        }
        String str = Integer.toBinaryString(temp);
        //   System.out.println("str = " + str);

        if (flag || temp < 0) {
            return str.substring(str.length() - 8);
        } else {
            return str;
        }

    }


    private static byte[] huffmanZip(byte[] bytes) {
        //创建集合存储元素
        List<Node> nodes = getNodes(bytes);
        //建立huffman树
        Node huffmanTree = createHuffmanTree(nodes);
        //获取huffman编码表
        Map<Byte, String> huffmanCodes = getCodes(huffmanTree);
        //取得经过压缩的字符串
        byte[] huffmanCodeBytes = zip(bytes, huffmanCodes);

        return huffmanCodeBytes;
    }

    //返回通过huffmanCode压缩后的字符串
    private static byte[] zip(byte[] bytes, Map<Byte, String> huffmanCodes) {
        StringBuilder stringBuilder = new StringBuilder();
        for (byte b : bytes) {      //将原先的字符串进行压缩
            stringBuilder.append(huffmanCodes.get(b));      //此时编码为二进制编码
        }
        //    System.out.println("Test = " + stringBuilder.toString());
        int len;
        //    int len = (stringBuilder.length() + 7) / 8;
        //统计返回byte数组的长度
        if (stringBuilder.length() % 8 == 0) {
            len = stringBuilder.length() / 8;
        } else {
            len = stringBuilder.length() / 8 + 1;
        }
        //创建存储压缩后的byte数组
        byte[] huffmanCodeBytes = new byte[len];
        int index = 0;      //计数器，记录当前加入的是第几个byte
        for (int i = 0; i < stringBuilder.length(); i += 8) {   //byte占1个字节，8位二进制数
            String strByte;
            //防止字符串长度不可以被8整除而可能会发生的数组越界
            if (i + 8 > stringBuilder.length()) {
                strByte = stringBuilder.substring(i);               //取从第i位开始后的全部数据
            } else {
                strByte = stringBuilder.substring(i, i + 8);        //从i取到i+8
            }
            //将steByte转换位byte，放入返回数组中
            huffmanCodeBytes[index] = (byte) Integer.parseInt(strByte, 2);
            index++;
        }
        return huffmanCodeBytes;        //返回byte数组
    }

    static Map<Byte, String> huffmanCodes = new HashMap<Byte, String>();

    static StringBuilder stringBuilder = new StringBuilder();

    private static Map<Byte, String> getCodes(Node root) {      //getCodes方法重载方便调用
        if (root == null) {
            return null;
        }
        getCodes(root.left, "0", stringBuilder);
        getCodes(root.right, "1", stringBuilder);
        return huffmanCodes;
    }

    //node为传入结点     code为路径     stringBuilder用于拼接路径
    private static void getCodes(Node node, String code, StringBuilder stringBuilder) {
        //实例化StringBuilder对象，并给stringBuilder2赋初值，以实现编码（路径）的保存
        StringBuilder stringBuilder2 = new StringBuilder(stringBuilder);
        stringBuilder2.append(code);            //添加走到该节点的最后一步路径
        if (node != null) {
            if (node.data == null) { //分别向左右遍历
                getCodes(node.left, "0", stringBuilder2);
                getCodes(node.right, "1", stringBuilder2);
            } else {
                //Map对象的put方法，及存放该结点的数据及他的拼接路径
                huffmanCodes.put(node.data, stringBuilder2.toString());
            }
        }
    }

    private static List<Node> getNodes(byte[] bytes) {
        ArrayList<Node> nodes = new ArrayList<Node>();

        Map<Byte, Integer> counts = new HashMap();

        for (byte b : bytes) {
            Integer count = counts.get(b);
            if (count == null) {
                counts.put(b, 1);
            } else {
                counts.put(b, count + 1);
            }
        }

        for (Map.Entry<Byte, Integer> entry : counts.entrySet()) {
            nodes.add(new Node(entry.getKey(), entry.getValue()));
        }
        return nodes;
    }

    private static Node createHuffmanTree(List<Node> nodes) {
        while (nodes.size() > 1) {      //当集合中的元素大于1
            Collections.sort(nodes);       //huffman树的构建过程
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            Node parent = new Node(null, leftNode.weight + rightNode.weight);
            parent.left = leftNode;
            parent.right = rightNode;

            nodes.remove(leftNode);     //移除结点
            nodes.remove(rightNode);

            nodes.add(parent);      //添加处理好的结点
        }

        return nodes.get(0);        //返回huffman树的根结点
    }
}

//实现comparable接口以方便排序
class Node implements Comparable<Node> {
    Byte data;      //数据
    int weight;     //权重
    Node left;      //左右指针
    Node right;

    public Node(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }

    @Override       //重写compareTo便于结点排序
    public int compareTo(Node o) {
        return this.weight - o.weight;
    }

    @Override       //重写toString
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", weight=" + weight +
                '}';
    }

    //前序遍历
    public void preOrder() {
        System.out.println(this);
        if (this.left != null) {
            this.left.preOrder();
        }
        if (this.right != null) {
            this.right.preOrder();
        }
    }
}
```





## BST

排序二叉树

```java

import java.util.*;

public class hello {
    public static void main(String[] args) {
        int arr[] = {7,3,10,12,5,1,9,2};
        BinarySortTree binarySortTree = new BinarySortTree();
        for (int i = 0; i < arr.length; i++) {
            binarySortTree.add(new Node(arr[i]));
        }
        System.out.println("中序遍历BST ");
        binarySortTree.infixOrder();

        binarySortTree.delNode(2);
        binarySortTree.delNode(5);
        binarySortTree.delNode(9);
        binarySortTree.delNode(12);
        binarySortTree.delNode(7);
        binarySortTree.delNode(3);
        System.out.println("root = " + binarySortTree.getRoot());
        binarySortTree.delNode(10);
        binarySortTree.delNode(1);

        System.out.println("中序遍历BST ");
        binarySortTree.infixOrder();
    }
}

class BinarySortTree {
    private Node root;

    public void add(Node node) {        //添加结点
        if(root == null) {
            root = node;
        } else {
            root.add(node);
        }
    }

    public Node getRoot() {
        return root;
    }

    public void infixOrder() {
        if(root != null) {
            root.infixOrder();
        } else {
            System.out.println("树为空");
        }
    }

    public int delRightTreeMin(Node node) {     //删除右子树最小的结点并返回该结点的值
        Node target = node;

        while(target.left != null) {        //找到右节点最小的值
            target = target.left;
        }

        delNode(target.value);
        return target.value;
    }

    public void delNode(int value) {        //删除结点
        if(root == null) {
            return;
        } else {
            Node targetNode = search(value);
            if(targetNode == null) {        //没有找到要删除的结点
                return;
            }

            if(root.left == null && root.right == null) {   //当该树只有一个节点时
                root = null;
                return;
            }

            Node parent = searchParent(value);
            if(targetNode.left == null && targetNode.right == null) {       //当该结点为叶子结点
                if(parent.left != null && parent.left.value == value) {     //当该结点为父节点的左子结点
                    parent.left = null;
                } else if(parent.right != null && parent.right.value == value) {
                    parent.right = null;
                }
            } else if (targetNode.left != null && targetNode.right != null) {
                targetNode.value = delRightTreeMin(targetNode.right);       //当该结点左右结点都不为空时
            } else {        //只有一棵子树的结点
                if(targetNode.left != null) {       //targetNode为parent的左子节点
                    if(parent != null) {        //当该结点不为根节点时
                        if(parent.left.value == value) {        //该结点为parent结点的左子结点
                            parent.left = targetNode.left;
                        } else {
                            parent.right = targetNode.left;
                        }
                    } else {        //为根节点时直接让root指向该结点
                        root = targetNode.left;
                    }

                } else {                //targetNode为parent的右子节点
                    if(parent != null) {
                        if(parent.left.value == value) {    //该结点为parent结点的右子结点
                            parent.left = targetNode.right;
                        } else {
                            parent.right = targetNode.right;
                        }
                    } else {
                        root = targetNode.right;
                    }

                }

            }

        }

    }

    
    public Node search(int value) {
        if(root == null) {
            return null;
        } else {
            return root.search(value);
        }
    }

    public Node searchParent(int value) {
        if(root == null) {
            return null;
        } else {
            return root.searchParent(value);
        }
    }


}



class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    public Node search(int value) {     //查找该结点
        if(value == this.value) {
            return this;
            //如果值大于带节点则向右查找
        } else if(value < this.value){
            if(this.left == null) {
                return null;
            }
            return this.left.search(value);
            //如果值小于带节点则向左查找
        } else {
            if(this.right == null){
                return null;
            }
            return this.right.search(value);
        }
    }

    public Node searchParent(int value) {       //查找该结点的夫结点
        //当该结点的左右子结点非空且为查找结点时
        if((this.left != null && this.left.value == value) ||
                (this.right != null && this.right.value == value)) {
            return this;        //返回该结点
        } else {
            //左子结点不为空则向左递归查找
            if(this.left != null && value < this.value) {
                return this.left.searchParent(value);
            //右子结点不为空则向左递归查找
            } else if(this.right != null && value >= this.value) {
                return this.right.searchParent(value);
            } else {    //否则返回空
                return null;
            }
        }
    }


    public void add(Node node) {
        if(node == null) {
            return;
        }

        if(node.value < this.value) {       //当添加结点值小于该结点值时
            if(this.left == null) {         //如果该结点左结点为空
                this.left = node;
            } else {        //向左递归添加
                this.left.add(node);
            }
        } else {            //当添加结点值大于该结点值时
            if(this.right == null) {
                this.right = node;
            } else {        //向右递归添加
                this.right.add(node);
            }
        }
    }

    public void infixOrder() {      //中序遍历
        if(this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right != null) {
            this.right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }
}

```





## 平衡二叉树

平衡二叉树也叫平衡二叉搜索树，为空树或左右两个子树的高度差不超过1，并且左右两个子树都是一棵平衡二叉树

常用的实现方法有：红黑树，AVL，替罪羊树，Treap，伸展树等





```java
import java.util.*;

public class hello {
    public static void main(String[] args) {
    //    int[] arr = {4,3,6,5,7,8};
        int[] arr = {10,11,7,6,8,9};
        AVLTree avlTree = new AVLTree();
        for (int i = 0; i < arr.length; i++) {
            avlTree.add(new Node(arr[i]));
        }

        System.out.println("infixOrder " );
        avlTree.infixOrder();
        System.out.println("Height");
        System.out.println(avlTree.getRoot().height());
        System.out.println("leftHeight = " + avlTree.getRoot().leftHeight());
        System.out.println("rightHeight = " + avlTree.getRoot().rightHeight());
        System.out.println("Root = " + avlTree.getRoot());
    }
}

class AVLTree {
    private Node root;

    public void add(Node node) {        //添加结点
        if(root == null) {
            root = node;
        } else {
            root.add(node);
        }
    }



    public Node getRoot() {
        return root;
    }

    public void infixOrder() {
        if(root != null) {
            root.infixOrder();
        } else {
            System.out.println("树为空");
        }
    }

    public int delRightTreeMin(Node node) {     //删除右子树最小的结点并返回该结点的值
        Node target = node;

        while(target.left != null) {        //找到右节点最小的值
            target = target.left;
        }

        delNode(target.value);
        return target.value;
    }

    public void delNode(int value) {        //删除结点
        if(root == null) {
            return;
        } else {
            Node targetNode = search(value);
            if(targetNode == null) {        //没有找到要删除的结点
                return;
            }

            if(root.left == null && root.right == null) {   //当该树只有一个节点时
                root = null;
                return;
            }

            Node parent = searchParent(value);
            if(targetNode.left == null && targetNode.right == null) {       //当该结点为叶子结点
                if(parent.left != null && parent.left.value == value) {     //当该结点为父节点的左子结点
                    parent.left = null;
                } else if(parent.right != null && parent.right.value == value) {
                    parent.right = null;
                }
            } else if (targetNode.left != null && targetNode.right != null) {
                targetNode.value = delRightTreeMin(targetNode.right);       //当该结点左右结点都不为空时
            } else {        //只有一棵子树的结点
                if(targetNode.left != null) {       //targetNode为parent的左子节点
                    if(parent != null) {        //当该结点不为根节点时
                        if(parent.left.value == value) {        //该结点为parent结点的左子结点
                            parent.left = targetNode.left;
                        } else {
                            parent.right = targetNode.left;
                        }
                    } else {        //为根节点时直接让root指向该结点
                        root = targetNode.left;
                    }

                } else {                //targetNode为parent的右子节点
                    if(parent != null) {
                        if(parent.left.value == value) {    //该结点为parent结点的右子结点
                            parent.left = targetNode.right;
                        } else {
                            parent.right = targetNode.right;
                        }
                    } else {
                        root = targetNode.right;
                    }

                }

            }

        }

    }


    public Node search(int value) {
        if(root == null) {
            return null;
        } else {
            return root.search(value);
        }
    }

    public Node searchParent(int value) {
        if(root == null) {
            return null;
        } else {
            return root.searchParent(value);
        }
    }
}





class Node {
    int value;
    Node left;
    Node right;

    public Node(int value) {
        this.value = value;
    }

    public int leftHeight() {
        if(left == null) {
             return 0;
        }
        return left.height();
    }

    public int rightHeight() {
        if(right == null) {
            return  0;
        }
        return right.height();
    }


    //
    public int height() {
        return Math.max(left == null ? 0 : left.height(),
                right == null ? 0 : right.height()) + 1;
    }

    private void leftRotate() {
        Node newNode = new Node(value);

        newNode.left = left;

        newNode.right = right.left;

        value = right.value;

        right = right.right;

        left = newNode;

    }

    private void rightRotate() {
        Node newNode = new Node(value);
        newNode.right = right;
        newNode.left = left.right;
        value = left.value;
        left = left.left;
        right = newNode;
    }



    public Node search(int value) {     //查找该结点
        if(value == this.value) {
            return this;
            //如果值大于带节点则向右查找
        } else if(value < this.value){
            if(this.left == null) {
                return null;
            }
            return this.left.search(value);
            //如果值小于带节点则向左查找
        } else {
            if(this.right == null){
                return null;
            }
            return this.right.search(value);
        }
    }

    public Node searchParent(int value) {       //查找该结点的夫结点
        //当该结点的左右子结点非空且为查找结点时
        if((this.left != null && this.left.value == value) ||
                (this.right != null && this.right.value == value)) {
            return this;        //返回该结点
        } else {
            //左子结点不为空则向左递归查找
            if(this.left != null && value < this.value) {
                return this.left.searchParent(value);
                //右子结点不为空则向左递归查找
            } else if(this.right != null && value >= this.value) {
                return this.right.searchParent(value);
            } else {    //否则返回空
                return null;
            }
        }
    }


    public void add(Node node) {
        if(node == null) {
            return;
        }

        if(node.value < this.value) {       //当添加结点值小于该结点值时
            if(this.left == null) {         //如果该结点左结点为空
                this.left = node;
            } else {        //向左递归添加
                this.left.add(node);
            }
        } else {            //当添加结点值大于该结点值时
            if(this.right == null) {
                this.right = node;
            } else {        //向右递归添加
                this.right.add(node);
            }
        }
        //当右子树的高度大于左子树加1
        if(rightHeight() - leftHeight() > 1) {
            //如果当前结点的右子树的左子树高度，高度大于当前结点右子树的右子树高度时
            //需先对右子节点进行右旋转
            //之后在对当前结点进行左旋转
            if(right != null && right.rightHeight() < right.leftHeight()) {
                right.rightRotate();
                leftRotate();   //左旋转
            } else {
                leftRotate();
            }
            return;        //已平衡,直接返回
        }
        if(leftHeight() - rightHeight() > 1) {
            if(left != null && left.rightHeight() > left.leftHeight()) {
                left.leftRotate();
                rightRotate();      //右旋转
            } else {
                rightRotate();
            }
        }
        
    }

    public void infixOrder() {      //中序遍历
        if(this.left != null) {
            this.left.infixOrder();
        }
        System.out.println(this);
        if(this.right != null) {
            this.right.infixOrder();
        }
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }
}
```









## 多叉树

### B树，B-树

B树就是B-树

是平衡树

B树的阶为结点的最多子结点个数

关键字集合分布在整棵树中，即叶子节点和非叶子结点都存放数据



### B+树

B+树是B树的变体，区别是B+树所有的关键字都出现在叶子结点的链表中

非叶子结点相当于非叶子结点的索引

更适合文件索引系统



### B*树

B*树是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针





# 图 （graph）



## DFS

利用递归或栈实现

```java
import java.util.*;

public class hello {
    private ArrayList<String> vertexList;
    private int[][] edges;
    private int numOfEdges;
    private boolean[] isVisited;

    public static void main(String[] args) {
        int n = 5;
        String[] vertexValue = {"A","B","C","D","E"};
        hello graph = new hello(n);
        for(String vertex : vertexValue) {
            graph.insertVertex(vertex);
        }
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);
        
        graph.showGraph();
        graph.dfs();


    }

    //构造器
    public hello(int n) {
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        numOfEdges = 0;

    }

   //寻找第一个邻接结点
    public int getFirstNeighbor(int index) {
        for (int j = 0; j < vertexList.size(); j++) {
            if(edges[index][j] > 0) {
                return j;
            }
        }
        return -1;
    }

     //寻找下一个邻接结点
    public int getNextNeighbor(int v1, int v2) {
        for (int j = v2 + 1; j < vertexList.size(); j++) {
            if(edges[v1][j] > 0) {
                return j;
            }
        }
        return -1;
    }

    public void dfs(boolean[] isVisited, int i) {
        //访问该结点
        System.out.print(getValueByIndex(i) + " -> ");
        isVisited[i] = true;
        //w为第一个邻接结点
        int w = getFirstNeighbor(i);
        //表示w还存在邻接结点
        while (w != -1) {
            if(!isVisited[w]) {
                dfs(isVisited,w);
            }
            //寻找还与w相邻接的结点
            w = getNextNeighbor(i,w);
        }

    }

    public void dfs() {
        isVisited = new boolean[5];
        //循环遍历所有结点
        for (int i = 0; i < getNumOfVertex(); i++) {
            if(!isVisited[i]) {
                dfs(isVisited,i);
            }
        }
    }



	//获取结点个数
    public int getNumOfVertex() {
        return vertexList.size();
    }

    //获取边的个数
    public int getNumOfEdges() {
        return numOfEdges;
    }

    //通过指针访问该结点
    public String getValueByIndex(int i) {
        return vertexList.get(i);
    }

    //获取两结点之间的权值
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }
	
    //显示邻接矩阵
    public void showGraph() {
        for(int[] link : edges) {
            System.err.println(Arrays.toString(link));
        }
    }

	//插入结点
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    //weight代表权值，即是否为通
    public void insertEdge(int v1, int v2, int weight) {
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }





}
```









## BFS

利用队列实现

```java

import java.util.*;

public class hello {
    private ArrayList<String> vertexList;
    private int[][] edges;
    private int numOfEdges;
    private boolean[] isVisited;

    public static void main(String[] args) {
        int n = 5;
        String[] vertexValue = {"A","B","C","D","E"};
        hello graph = new hello(n);
        for(String vertex : vertexValue) {
            graph.insertVertex(vertex);
        }
        graph.insertEdge(0,1,1);
        graph.insertEdge(0,2,1);
        graph.insertEdge(1,2,1);
        graph.insertEdge(1,3,1);
        graph.insertEdge(1,4,1);

        System.out.println("AA");
        graph.showGraph();
        System.out.print("BFS = ");
        graph.bfs();
        System.out.println();


    }

    //构造器
    public hello(int n) {
        edges = new int[n][n];
        vertexList = new ArrayList<String>(n);
        numOfEdges = 0;


    }

    //寻找第一个邻接结点
    public int getFirstNeighbor(int index) {
        for (int j = 0; j < vertexList.size(); j++) {
            if(edges[index][j] > 0) {
                return j;
            }
        }
        return -1;
    }
    
    //寻找下一个邻接结点
    public int getNextNeighbor(int v1, int v2) {
        for (int j = v2 + 1; j < vertexList.size(); j++) {
            if(edges[v1][j] > 0) {
                return j;
            }
        }
        return -1;
    }
    
    public void bfs(boolean[] isVisited,int i) {
        int u;      //表示队列头结点
        int w;      //表示邻接结点
        LinkedList queue = new LinkedList();        //模拟队列
        System.out.print(getValueByIndex(i) + " -> ");      //访问该结点
        isVisited[i] = true;
        queue.addLast(i);       //入队列

        while (!queue.isEmpty()) {
            //访问后该结点出队列
            u = (Integer) queue.removeFirst();
            //w表示下一个邻接结点
            w = getFirstNeighbor(u);
            //还有路可寻时
            while (w != -1) {
                if(!isVisited[w]) {     //当w未被访问
                    System.out.print(getValueByIndex(w) + " -> ");      //访问该结点
                    isVisited[w] = true;
                    queue.addLast(w);       //入队列
                }
                //以u为前驱结点搜索下一个结点
                w = getNextNeighbor(u,w);
            }
        }
    }


    public void bfs() {
        //初始化数组
        isVisited = new boolean[5];
        //循环遍历所有结点
        for (int i = 0; i < getNumOfVertex(); i++) {
            if(!isVisited[i]) {
                bfs(isVisited,i);
            }
        }
    }
    

    //获取结点个数
    public int getNumOfVertex() {
        return vertexList.size();
    }

    //获取边的个数
    public int getNumOfEdges() {
        return numOfEdges;
    }

    //通过指针访问该结点
    public String getValueByIndex(int i) {
        return vertexList.get(i);
    }

    //获取两结点之间的权值
    public int getWeight(int v1, int v2) {
        return edges[v1][v2];
    }
	
    //显示邻接矩阵
    public void showGraph() {
        for(int[] link : edges) {
            System.err.println(Arrays.toString(link));
        }
    }

	//插入结点
    public void insertVertex(String vertex) {
        vertexList.add(vertex);
    }

    //weight代表权值，即是否为通
    public void insertEdge(int v1, int v2, int weight) {
        edges[v1][v2] = weight;
        edges[v2][v1] = weight;
        numOfEdges++;
    }





}



```









# 算法（Algorithm）



## 分治算法

分而治之。将一个复杂的问题分成两个或更多相同或相似的子问题，再将子问题继续分解，

直到最后子问题可以简单的直接求解，原问题的解即子问题解的合并



### 二分查找（非递归）

```java
import java.util.*;

public class hello {
    public static void main(String[] args) {
        int[] arr = {1,3,8,10,11,67,100};
        System.out.println("index = " + binarySearch(arr,8));
    }

    public static int binarySearch(int[] arr, int target) {
        int left = 0;
        int right = arr.length - 1;
        while(left <= right) {
            int mid = (left + right) / 2;
            if(arr[mid] == target) {
                return mid;
            } else if (arr[mid] > target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return -1;
    }

}
```





### 汉诺塔

```java
import java.util.*;

public class hello {
    public static void main(String[] args) {
        hanoiTower(5,'A','B','C');
    }


    public static void hanoiTower(int num, char a, char b, char c) {
        if(num == 1) {
            System.out.println("第1个盘子从" + a + " -> " + c);
        } else {
            hanoiTower(num - 1, a, c, b);
            System.out.println("第" + num + "个盘子从" + a + " -> " + c);
            hanoiTower(num - 1, b, a, c);
        }
    }

}
```







## 动态规划













## KMP

